<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of arg_define</title>
  <meta name="keywords" content="arg_define">
  <meta name="description" content="Parse function arguments and enable function introspection.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">arguments</a> &gt; arg_define.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/arguments&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>arg_define

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Parse function arguments and enable function introspection.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function outstruct = arg_define(vals,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Parse function arguments and enable function introspection.
 Struct = arg_define(Values, Specification...)
 Struct = arg_define(Format, Values, Specification...)

 Replacement for the parameter declaration line of a function. Typically that Function will only
 declare a single varargin argument and then calls arg_define(varargin, ...) to parse it into a
 Struct. The Specification of allowed arguments with defaults, range and help text is given as a
 as a series of arg(), arg_sub(), etc. definitions, each of which declares one named argument.

 One can also omit the output Struct to have the arguments assigned directly into the Function's
 workspace, but that is discouraged  as it will only work for argument names that do not clash with
 any function on the MATLAB path (due to a limitation in MATLAB).

 The format of varargin is flexible and can be a list of a fixed number of positional arguments
 (i.e., the typical MATLAB calling format), optionally followed by a list of name-value pairs
 (NVPs, e.g., as the format accepted by figure()). The name-value pairs may be interleaved with
 option structs, i.e., one may pass a mix of 'name',value,STRUCT,'name',value,'name',value, ...),
 which is not ambiguous. The allowed number of positional arguments, if any, can be specified by
 the optional extra Format argument to arg_define. Only names that are listed in the Specification
 may be used as named arguments.

 A main feature of arg_define is that the argument specification can be reported to outside
 functions (queried using arg_report), which allows to auto-generate GUIs, help text, and various
 other things.

 In:
   Format : Can be omitted. The number of allowed positional arguments of the Function, or a vector
            of multiple possibilities. More precisely, this is the number of leading arguments that
            can be passed to the Function as positional arguments, while the remaining arguments
            are interpreted as a list of name-value pairs and/or option structs. See Format Options
            below for additional options and details. (default: [0 Inf])

   Values : A cell array of values passed to the function (usually the calling function's
            &quot;varargin&quot;). Interpreted according to the Format and the Specification.

   Specification... : The specification of the calling function's arguments; this is a sequence of
                      arg(), arg_norep(), arg_nogui(), arg_deprecated(), arg_sub(),
                      arg_subswitch(), arg_subtoggle() specifiers.

 Out:
   Struct : A struct with values assigned to fields, according to the Specification and Format.

            Note: If this output is not requested by the Function, the contents of Struct are
            instead assigned to the Function's workspace -- but note that this only works for
            variable names are *not* also names of functions in the path (due to a deficiency in
            MATLAB's treatment of variable identifiers). Thus, it is good advice to use variable
            names that are unlikely to be function names to avoid this situation (e.g.,
            long/expressive or CamelCase names).

 See also:
   <a href="arg.html" class="code" title="function res = arg(varargin)">arg</a>, <a href="arg_nogui.html" class="code" title="function res = arg_nogui(varargin)">arg_nogui</a>, <a href="arg_norep.html" class="code" title="function res = arg_norep(varargin)">arg_norep</a>, <a href="arg_deprecated.html" class="code" title="function res = arg_deprecated(varargin)">arg_deprecated</a>, <a href="arg_sub.html" class="code" title="function res = arg_sub(varargin)">arg_sub</a>, <a href="arg_subswitch.html" class="code" title="function res = arg_subswitch(varargin)">arg_subswitch</a>, <a href="arg_subtoggle.html" class="code" title="function res = arg_subtoggle(varargin)">arg_subtoggle</a>

 Format Options:
    * If Format is a vector of multiple values, then the smallest number for which the
      Function's inputs are consistent, in the sense that each name in Values matches a
      name in the Specification, is accepted.
    * If Format is numeric but does not contain a 0, a 0 will be implicitly prepended
      (that is, one can always pass in everything as name-value pairs or structs).
    * If Format is [], any number of positional arguments is allowed (i.e., Format defaults
      to 0:length(Specification)), although this is discouraged in practice as it may
      result in mis-parsing when mis-spelled arguments are passed in (arg_define would then
      assume that anything up to the mis-spelled argument is passed in positionally).
    * If Format is a function handle, the given function can be used to transform the
      Values prior to any other processing into a new Values cell array. This allows for arbitrary
      customizations of the parameter syntax (but note that the function must always be able to
      accept name-value pair/struct syntax, too). This function may optionally return a new
      (numeric) Format as its second output argument (if not specified, this is assumed to be 0).
      The function may optionally take in the argument specification (struct array of
      <a href="arg_specifier.html" class="code" title="function spec = arg_specifier(varargin)">arg_specifier</a>, which holds the names, types, defaults, etc. of the defined arguments),
      although some details of this data structure are internal and subject to change in future
      releases (particularly fields marked as INTERNAL).
    * If Format is the special string 'allow-unlisted-names', it has the same effect as setting
      Format to 0, and in addition the list of name-value pairs given may contain names that are
      not among those specified in the arguments.

 Performance Tips:
   1) If a name-value pair 'arg_direct',true is passed (preferably as last argument for best
      performance), or a struct with a field named 'arg_direct' is passed (that is set to true),
      then only the values that are passed in will be assigned (and all type checking and default
      values are skipped); note that positional arguments are unsupported in this mode. This is a
      fast way to call a function (not much slower than hand-written argument parsing), and it
      usually means that all arguments should be passed in. To obtain a struct with the full set of
      function arguments to pass in (and their defaults), one can use <a href="arg_report.html" class="code" title="function result = arg_report(type,func,args)">arg_report</a>.

      Please do not pass multiple occurrences of 'arg_direct' with conflicting values to
      <a href="arg_define.html" class="code" title="function outstruct = arg_define(vals,varargin)">arg_define</a>, since the resulting behavior is then undefined.

   2) If a function has many arguments it is faster to receive the arguments in a struct (optional
      return value of arg_define) rather than to have them assigned to the function workspace.

 Internal Arguments and Return Values:
   The Function may be called with the request to deliver the parameter specification as opposed to
   following the normal execution flow (this is done by arg_report). This is implemented by passing
   in the internal name-value pair '__arg_report__',true at the end. <a href="arg_define.html" class="code" title="function outstruct = arg_define(vals,varargin)">arg_define</a> responds to this
   task by throwing an exception of the type 'BCILAB:arg:report_args' using <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>, which
   is caught by <a href="arg_report.html" class="code" title="function result = arg_report(type,func,args)">arg_report</a> to obtain the specification struct. When a report is issued the function
   may be called with some further internal arguments preceding the '__arg_report__',true,
   including __arg_skip__,true (skip leading skippable arguments) and __arg_nodefaults__,true (do
   not return default values). These arguments are subject to change and should not be used in user
   code.

 Examples:
   function myfunction(varargin)

   % begin a default argument declaration and declare a few arguments; The arguments can be passed either:
   % - by position: myfunction(4,20); including the option to leave some values at their defaults, e.g. myfunction(4) or myfunction()
   % - by name: myfunction('test',4,'blah',20); myfunction('blah',21,'test',4); myfunction('blah',22);
   % - as a struct: myfunction(struct('test',4,'blah',20))
   % - as a sequence of either name-value pairs or structs: myfunction('test',4,struct('blah',20)) (note that this is not ambiguous, as the struct would come in a place where only a name could show up otherwise
   arg_define(varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

   % a special syntax that is allowed is passing a particular parameter multiple times - in which case only the last specification is effective
   % myfunction('test',11, 'blah',21, 'test',3, struct('blah',15,'test',5), 'test',10) --&gt; test will be 10, blah will be 15

   % begin an argument declaration which allows 0 positional arguments (i.e. everything must be passed by name
   arg_define(0,varargin, ...

   % begin an argument declaration which allows exactly 1 positional arguments, i.e. the first one must be passed by position and the other one by name (or struct)
   % valid calls would be: myfunction(3,'blah',25); myfunction(3); myfunction(); (the last one assumes the default for both)
   arg_define(1,varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

   % begin an argument decalration which allows either 2 positional arguments or 0 positional arguments (i.e. either the first two are passed by position, or all are passed by name)
   % some valid calls are: myfunction(4,20,'flag',true); myfunction(4,20); myfunction(4,20,'xyz','test','flag',true); myfunction(4); myfunction('flag',true,'test',4,'blah',21); myfunction('flag',true)
   arg_define([0 2],varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'), ...
       arg('xyz','defaultstr',[],'XYZ.'), ...
       arg('flag',false,[],'Some flag.'));

   % begin an argument declaration in which the formatting of arguments is completely arbitrary, and a custom function takes care of bringing them into a form understood by
   % the <a href="arg_define.html" class="code" title="function outstruct = arg_define(vals,varargin)">arg_define</a> implementation. This function takes a cell array of arguments (in any formatting), and returns a cell array of a standard formatting (e.g. name-value pairs, or structs)
   arg_define(@myparser,varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

   % return the arguments as fields in a struct (here: opts), instead of directly in the workspace
   opts = arg_define(varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
                                2010-09-24</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>	Internal function to yield a report to a requesting function.</li>
<li><a href="arg_report.html" class="code" title="function result = arg_report(type,func,args)">arg_report</a>	Report information of a certain Type about the given Function.</li>
<li><a href="arg_specifier.html" class="code" title="function spec = arg_specifier(varargin)">arg_specifier</a>	Internal: create a base specifier struct for an argument.</li>
<li><a href="arg_tovals.html" class="code" title="function res = arg_tovals(spec,set_direct,format,mandatory_check,unassigned_check,expression_check,conversion_check)">arg_tovals</a>	Reformat an argument specification for a function into a valid input argument.</li>
<li><a href="cached_argument.html" class="code" title="function result = cached_argument(name,default)">cached_argument</a>	Helper: return an arg_nogui() specifier with the given name/default value</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">

</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="#_sub1" class="code">function [fmt,vals,compressed_spec,structmask,report_type,skip,nodefaults] = process_inputs(vals,compressed_spec)</a></li>
<li><a href="#_sub2" class="code">function direct_mode = is_direct_mode(vals,structmask)</a></li>
<li><a href="#_sub3" class="code">function [nvps,outstruct] = assign_direct(vals,structmask,make_struct)</a></li>
<li><a href="#_sub4" class="code">function varargout = process_spec_cached(caller_name,spec,report_type,assign_defaults,perform_namecheck)</a></li>
<li><a href="#_sub5" class="code">function [spec,flat_names,first_names,name2idx,leading_skippable,checks] = process_spec(caller_name,compressed_spec,report_type,assign_defaults,perform_namecheck)</a></li>
<li><a href="#_sub6" class="code">function spec = expand_spec(spec,report_type,assign_defaults,caller_name)</a></li>
<li><a href="#_sub7" class="code">function ismatch = check_property(spec,name,value)</a></li>
<li><a href="#_sub8" class="code">function nvps = arguments_to_nvps(caller_name,fmt,vals,structmask,flat_names,first_names,skipped_positionals,suppress_warnings_for)</a></li>
<li><a href="#_sub9" class="code">function [num_positionals,violations,ignored] = get_num_positionals(fmt,spec_length,signature,structmask,permitted_names,skipped_positionals)</a></li>
<li><a href="#_sub10" class="code">function spec = assign_nvps(spec,nvps,name2idx,report_type,caller_name,deprecation_warning)</a></li>
<li><a href="#_sub11" class="code">function spec = assign_value(spec,newvalue,report_type,caller_name,nodefaults,deprecation_warning,respect_empty_overwrites)</a></li>
<li><a href="#_sub12" class="code">function check_value(spec,newvalue,caller_name)</a></li>
<li><a href="#_sub13" class="code">function warn_deprecation(spec,caller_name)</a></li>
</ul>




<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function outstruct = arg_define(vals,varargin)</a>
0002 <span class="comment">% Parse function arguments and enable function introspection.</span>
0003 <span class="comment">% Struct = arg_define(Values, Specification...)</span>
0004 <span class="comment">% Struct = arg_define(Format, Values, Specification...)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Replacement for the parameter declaration line of a function. Typically that Function will only</span>
0007 <span class="comment">% declare a single varargin argument and then calls arg_define(varargin, ...) to parse it into a</span>
0008 <span class="comment">% Struct. The Specification of allowed arguments with defaults, range and help text is given as a</span>
0009 <span class="comment">% as a series of arg(), arg_sub(), etc. definitions, each of which declares one named argument.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% One can also omit the output Struct to have the arguments assigned directly into the Function's</span>
0012 <span class="comment">% workspace, but that is discouraged  as it will only work for argument names that do not clash with</span>
0013 <span class="comment">% any function on the MATLAB path (due to a limitation in MATLAB).</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% The format of varargin is flexible and can be a list of a fixed number of positional arguments</span>
0016 <span class="comment">% (i.e., the typical MATLAB calling format), optionally followed by a list of name-value pairs</span>
0017 <span class="comment">% (NVPs, e.g., as the format accepted by figure()). The name-value pairs may be interleaved with</span>
0018 <span class="comment">% option structs, i.e., one may pass a mix of 'name',value,STRUCT,'name',value,'name',value, ...),</span>
0019 <span class="comment">% which is not ambiguous. The allowed number of positional arguments, if any, can be specified by</span>
0020 <span class="comment">% the optional extra Format argument to arg_define. Only names that are listed in the Specification</span>
0021 <span class="comment">% may be used as named arguments.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% A main feature of arg_define is that the argument specification can be reported to outside</span>
0024 <span class="comment">% functions (queried using arg_report), which allows to auto-generate GUIs, help text, and various</span>
0025 <span class="comment">% other things.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% In:</span>
0028 <span class="comment">%   Format : Can be omitted. The number of allowed positional arguments of the Function, or a vector</span>
0029 <span class="comment">%            of multiple possibilities. More precisely, this is the number of leading arguments that</span>
0030 <span class="comment">%            can be passed to the Function as positional arguments, while the remaining arguments</span>
0031 <span class="comment">%            are interpreted as a list of name-value pairs and/or option structs. See Format Options</span>
0032 <span class="comment">%            below for additional options and details. (default: [0 Inf])</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%   Values : A cell array of values passed to the function (usually the calling function's</span>
0035 <span class="comment">%            &quot;varargin&quot;). Interpreted according to the Format and the Specification.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%   Specification... : The specification of the calling function's arguments; this is a sequence of</span>
0038 <span class="comment">%                      arg(), arg_norep(), arg_nogui(), arg_deprecated(), arg_sub(),</span>
0039 <span class="comment">%                      arg_subswitch(), arg_subtoggle() specifiers.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% Out:</span>
0042 <span class="comment">%   Struct : A struct with values assigned to fields, according to the Specification and Format.</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%            Note: If this output is not requested by the Function, the contents of Struct are</span>
0045 <span class="comment">%            instead assigned to the Function's workspace -- but note that this only works for</span>
0046 <span class="comment">%            variable names are *not* also names of functions in the path (due to a deficiency in</span>
0047 <span class="comment">%            MATLAB's treatment of variable identifiers). Thus, it is good advice to use variable</span>
0048 <span class="comment">%            names that are unlikely to be function names to avoid this situation (e.g.,</span>
0049 <span class="comment">%            long/expressive or CamelCase names).</span>
0050 <span class="comment">%</span>
0051 <span class="comment">% See also:</span>
0052 <span class="comment">%   arg, arg_nogui, arg_norep, arg_deprecated, arg_sub, arg_subswitch, arg_subtoggle</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% Format Options:</span>
0055 <span class="comment">%    * If Format is a vector of multiple values, then the smallest number for which the</span>
0056 <span class="comment">%      Function's inputs are consistent, in the sense that each name in Values matches a</span>
0057 <span class="comment">%      name in the Specification, is accepted.</span>
0058 <span class="comment">%    * If Format is numeric but does not contain a 0, a 0 will be implicitly prepended</span>
0059 <span class="comment">%      (that is, one can always pass in everything as name-value pairs or structs).</span>
0060 <span class="comment">%    * If Format is [], any number of positional arguments is allowed (i.e., Format defaults</span>
0061 <span class="comment">%      to 0:length(Specification)), although this is discouraged in practice as it may</span>
0062 <span class="comment">%      result in mis-parsing when mis-spelled arguments are passed in (arg_define would then</span>
0063 <span class="comment">%      assume that anything up to the mis-spelled argument is passed in positionally).</span>
0064 <span class="comment">%    * If Format is a function handle, the given function can be used to transform the</span>
0065 <span class="comment">%      Values prior to any other processing into a new Values cell array. This allows for arbitrary</span>
0066 <span class="comment">%      customizations of the parameter syntax (but note that the function must always be able to</span>
0067 <span class="comment">%      accept name-value pair/struct syntax, too). This function may optionally return a new</span>
0068 <span class="comment">%      (numeric) Format as its second output argument (if not specified, this is assumed to be 0).</span>
0069 <span class="comment">%      The function may optionally take in the argument specification (struct array of</span>
0070 <span class="comment">%      arg_specifier, which holds the names, types, defaults, etc. of the defined arguments),</span>
0071 <span class="comment">%      although some details of this data structure are internal and subject to change in future</span>
0072 <span class="comment">%      releases (particularly fields marked as INTERNAL).</span>
0073 <span class="comment">%    * If Format is the special string 'allow-unlisted-names', it has the same effect as setting</span>
0074 <span class="comment">%      Format to 0, and in addition the list of name-value pairs given may contain names that are</span>
0075 <span class="comment">%      not among those specified in the arguments.</span>
0076 <span class="comment">%</span>
0077 <span class="comment">% Performance Tips:</span>
0078 <span class="comment">%   1) If a name-value pair 'arg_direct',true is passed (preferably as last argument for best</span>
0079 <span class="comment">%      performance), or a struct with a field named 'arg_direct' is passed (that is set to true),</span>
0080 <span class="comment">%      then only the values that are passed in will be assigned (and all type checking and default</span>
0081 <span class="comment">%      values are skipped); note that positional arguments are unsupported in this mode. This is a</span>
0082 <span class="comment">%      fast way to call a function (not much slower than hand-written argument parsing), and it</span>
0083 <span class="comment">%      usually means that all arguments should be passed in. To obtain a struct with the full set of</span>
0084 <span class="comment">%      function arguments to pass in (and their defaults), one can use arg_report.</span>
0085 <span class="comment">%</span>
0086 <span class="comment">%      Please do not pass multiple occurrences of 'arg_direct' with conflicting values to</span>
0087 <span class="comment">%      arg_define, since the resulting behavior is then undefined.</span>
0088 <span class="comment">%</span>
0089 <span class="comment">%   2) If a function has many arguments it is faster to receive the arguments in a struct (optional</span>
0090 <span class="comment">%      return value of arg_define) rather than to have them assigned to the function workspace.</span>
0091 <span class="comment">%</span>
0092 <span class="comment">% Internal Arguments and Return Values:</span>
0093 <span class="comment">%   The Function may be called with the request to deliver the parameter specification as opposed to</span>
0094 <span class="comment">%   following the normal execution flow (this is done by arg_report). This is implemented by passing</span>
0095 <span class="comment">%   in the internal name-value pair '__arg_report__',true at the end. arg_define responds to this</span>
0096 <span class="comment">%   task by throwing an exception of the type 'BCILAB:arg:report_args' using arg_issuereport, which</span>
0097 <span class="comment">%   is caught by arg_report to obtain the specification struct. When a report is issued the function</span>
0098 <span class="comment">%   may be called with some further internal arguments preceding the '__arg_report__',true,</span>
0099 <span class="comment">%   including __arg_skip__,true (skip leading skippable arguments) and __arg_nodefaults__,true (do</span>
0100 <span class="comment">%   not return default values). These arguments are subject to change and should not be used in user</span>
0101 <span class="comment">%   code.</span>
0102 <span class="comment">%</span>
0103 <span class="comment">% Examples:</span>
0104 <span class="comment">%   function myfunction(varargin)</span>
0105 <span class="comment">%</span>
0106 <span class="comment">%   % begin a default argument declaration and declare a few arguments; The arguments can be passed either:</span>
0107 <span class="comment">%   % - by position: myfunction(4,20); including the option to leave some values at their defaults, e.g. myfunction(4) or myfunction()</span>
0108 <span class="comment">%   % - by name: myfunction('test',4,'blah',20); myfunction('blah',21,'test',4); myfunction('blah',22);</span>
0109 <span class="comment">%   % - as a struct: myfunction(struct('test',4,'blah',20))</span>
0110 <span class="comment">%   % - as a sequence of either name-value pairs or structs: myfunction('test',4,struct('blah',20)) (note that this is not ambiguous, as the struct would come in a place where only a name could show up otherwise</span>
0111 <span class="comment">%   arg_define(varargin, ...</span>
0112 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0113 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0114 <span class="comment">%</span>
0115 <span class="comment">%   % a special syntax that is allowed is passing a particular parameter multiple times - in which case only the last specification is effective</span>
0116 <span class="comment">%   % myfunction('test',11, 'blah',21, 'test',3, struct('blah',15,'test',5), 'test',10) --&gt; test will be 10, blah will be 15</span>
0117 <span class="comment">%</span>
0118 <span class="comment">%   % begin an argument declaration which allows 0 positional arguments (i.e. everything must be passed by name</span>
0119 <span class="comment">%   arg_define(0,varargin, ...</span>
0120 <span class="comment">%</span>
0121 <span class="comment">%   % begin an argument declaration which allows exactly 1 positional arguments, i.e. the first one must be passed by position and the other one by name (or struct)</span>
0122 <span class="comment">%   % valid calls would be: myfunction(3,'blah',25); myfunction(3); myfunction(); (the last one assumes the default for both)</span>
0123 <span class="comment">%   arg_define(1,varargin, ...</span>
0124 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0125 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0126 <span class="comment">%</span>
0127 <span class="comment">%   % begin an argument decalration which allows either 2 positional arguments or 0 positional arguments (i.e. either the first two are passed by position, or all are passed by name)</span>
0128 <span class="comment">%   % some valid calls are: myfunction(4,20,'flag',true); myfunction(4,20); myfunction(4,20,'xyz','test','flag',true); myfunction(4); myfunction('flag',true,'test',4,'blah',21); myfunction('flag',true)</span>
0129 <span class="comment">%   arg_define([0 2],varargin, ...</span>
0130 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0131 <span class="comment">%       arg('blah',25,[],'Blah.'), ...</span>
0132 <span class="comment">%       arg('xyz','defaultstr',[],'XYZ.'), ...</span>
0133 <span class="comment">%       arg('flag',false,[],'Some flag.'));</span>
0134 <span class="comment">%</span>
0135 <span class="comment">%   % begin an argument declaration in which the formatting of arguments is completely arbitrary, and a custom function takes care of bringing them into a form understood by</span>
0136 <span class="comment">%   % the arg_define implementation. This function takes a cell array of arguments (in any formatting), and returns a cell array of a standard formatting (e.g. name-value pairs, or structs)</span>
0137 <span class="comment">%   arg_define(@myparser,varargin, ...</span>
0138 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0139 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0140 <span class="comment">%</span>
0141 <span class="comment">%   % return the arguments as fields in a struct (here: opts), instead of directly in the workspace</span>
0142 <span class="comment">%   opts = arg_define(varargin, ...</span>
0143 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0144 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0145 <span class="comment">%</span>
0146 <span class="comment">%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD</span>
0147 <span class="comment">%                                2010-09-24</span>
0148 
0149 <span class="comment">% Copyright (C) Christian Kothe, SCCN, 2010, christian@sccn.ucsd.edu</span>
0150 <span class="comment">%</span>
0151 <span class="comment">% This program is free software; you can redistribute it and/or modify it under the terms of the GNU</span>
0152 <span class="comment">% General Public License as published by the Free Software Foundation; either version 2 of the</span>
0153 <span class="comment">% License, or (at your option) any later version.</span>
0154 <span class="comment">%</span>
0155 <span class="comment">% This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without</span>
0156 <span class="comment">% even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
0157 <span class="comment">% General Public License for more details.</span>
0158 <span class="comment">%</span>
0159 <span class="comment">% You should have received a copy of the GNU General Public License along with this program; if not,</span>
0160 <span class="comment">% write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307</span>
0161 <span class="comment">% USA</span>
0162 
0163     <span class="comment">% first parse the inputs to arg_define</span>
0164     [fmt,vals,compressed_spec,structmask,report_type,skip,nodefaults] = <a href="#_sub1" class="code" title="subfunction [fmt,vals,compressed_spec,structmask,report_type,skip,nodefaults] = process_inputs(vals,compressed_spec)">process_inputs</a>(vals,varargin);
0165     
0166     <span class="comment">% check if we are in direct mode (fast shortcut)</span>
0167     <span class="keyword">if</span> strcmp(report_type,<span class="string">'none'</span>) &amp;&amp; <a href="#_sub2" class="code" title="subfunction direct_mode = is_direct_mode(vals,structmask)">is_direct_mode</a>(vals,structmask)
0168         <span class="comment">% in direct mode we assign only those variables that were passed in</span>
0169         [nvps,outstruct] = <a href="#_sub3" class="code" title="subfunction [nvps,outstruct] = assign_direct(vals,structmask,make_struct)">assign_direct</a>(vals,structmask,nargout);
0170     <span class="keyword">else</span>
0171         <span class="comment">% otherwise we perform full parsing</span>
0172         
0173         <span class="comment">% get the calling function's name (for cache lookups and diagnostics)</span>
0174         caller_name = determine_caller();
0175         
0176         <span class="comment">% expand specification into a struct array, derive some properties</span>
0177         [spec,flat_names,first_names,name2idx,leading_skippable,checks] = <a href="#_sub4" class="code" title="subfunction varargout = process_spec_cached(caller_name,spec,report_type,assign_defaults,perform_namecheck)">process_spec_cached</a>(caller_name,compressed_spec,report_type,~nodefaults,nargout==0);
0178 
0179         <span class="comment">% convert vals to a canonical list of name-value pairs (NVPs)</span>
0180         suppress_warnings_for = [spec(logical([spec.nowarning])).names {}];
0181         nvps = <a href="#_sub8" class="code" title="subfunction nvps = arguments_to_nvps(caller_name,fmt,vals,structmask,flat_names,first_names,skipped_positionals,suppress_warnings_for)">arguments_to_nvps</a>(caller_name,fmt,vals,structmask,flat_names,first_names,skip*leading_skippable,suppress_warnings_for);
0182 
0183         <span class="comment">% assign the NVPs to the spec</span>
0184         spec = <a href="#_sub10" class="code" title="subfunction spec = assign_nvps(spec,nvps,name2idx,report_type,caller_name,deprecation_warning)">assign_nvps</a>(spec,nvps,name2idx,report_type,caller_name,true);
0185 
0186         <span class="comment">% optionally remove unassigned spec entries</span>
0187         <span class="keyword">if</span> nodefaults &amp;&amp; ~isempty(spec)
0188             spec(strcmp(<span class="string">'__arg_unassigned__'</span>,{spec.value})) = []; <span class="keyword">end</span>
0189                 
0190         <span class="comment">% generate outputs from spec</span>
0191         <span class="keyword">switch</span> report_type
0192             <span class="keyword">case</span> <span class="string">'none'</span>
0193                 <span class="comment">% reset the skippable flag (these arguments are not &quot;skippable&quot; as far as the Function</span>
0194                 <span class="comment">% to which we're returning them is concerned)</span>
0195                 [spec.skippable] = deal(false);
0196                 <span class="comment">% handle mandatory entries</span>
0197                 mandatory_entries = find(strcmp(<span class="string">'__arg_mandatory__'</span>,{spec.value}));
0198                 <span class="keyword">if</span> mandatory_entries
0199                     error([<span class="string">'The arguments '</span> hlp_tostring({spec(mandatory_entries).first_name}) <span class="string">' were unspecified but are mandatory.'</span>]); <span class="keyword">end</span>
0200                 <span class="comment">% build output struct and generate full NVP list for assignment to workspace</span>
0201                 outstruct = <a href="arg_tovals.html" class="code" title="function res = arg_tovals(spec,set_direct,format,mandatory_check,unassigned_check,expression_check,conversion_check)">arg_tovals</a>(spec,[],<span class="string">'struct'</span>,false,checks.unassigned,checks.expression,checks.conversion);
0202                 nvps = reshape([fieldnames(outstruct)';struct2cell(outstruct)'],1,[]);
0203             <span class="keyword">case</span> <span class="string">'vals'</span>
0204                 <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(<a href="arg_tovals.html" class="code" title="function res = arg_tovals(spec,set_direct,format,mandatory_check,unassigned_check,expression_check,conversion_check)">arg_tovals</a>(spec,[],<span class="string">'struct'</span>,false,checks.unassigned,checks.expression,checks.conversion));
0205             <span class="keyword">case</span> <span class="string">'nvps'</span>
0206                 <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(<a href="arg_tovals.html" class="code" title="function res = arg_tovals(spec,set_direct,format,mandatory_check,unassigned_check,expression_check,conversion_check)">arg_tovals</a>(spec,[],<span class="string">'cell'</span>,false,checks.unassigned,checks.expression,checks.conversion));
0207             <span class="keyword">case</span> {<span class="string">'lean'</span>,<span class="string">'rich'</span>}
0208                 <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(spec);
0209             <span class="keyword">otherwise</span>
0210                 error([<span class="string">'Unrecognized report type requested: '</span> report_type]);
0211         <span class="keyword">end</span>
0212     <span class="keyword">end</span>
0213     
0214     <span class="comment">% if requested, place the arguments in the caller's workspace</span>
0215     <span class="keyword">if</span> ~nargout
0216         <span class="keyword">try</span>
0217             <span class="keyword">for</span> k=1:2:length(nvps)
0218                 assignin(<span class="string">'caller'</span>,nvps{k},nvps{k+1}); <span class="keyword">end</span>
0219         <span class="keyword">catch</span> e
0220             <span class="keyword">if</span> strcmp(e.identifier,<span class="string">'MATLAB:err_static_workspace_violation'</span>)
0221                 error(<span class="string">'In a function with nested functions you need to capture the outputs of arg_define into a struct.'</span>);
0222             <span class="keyword">else</span>
0223                 rethrow(e);
0224             <span class="keyword">end</span>
0225         <span class="keyword">end</span>
0226     <span class="keyword">end</span>
0227 
0228     <span class="comment">% also generally return the arguments in their native NVP/struct form</span>
0229     <span class="keyword">try</span>        
0230         assignin(<span class="string">'caller'</span>,<span class="string">'arg_nvps'</span>,nvps);
0231     <span class="keyword">catch</span> <span class="comment">%#ok&lt;CTCH&gt;</span>
0232         <span class="comment">% this operation might be disallowed under some circumstances (e.g., arg_define in a nested function)</span>
0233     <span class="keyword">end</span>
0234 <span class="keyword">end</span>
0235 
0236 
0237 <span class="comment">% process the inputs to arg_define into Format, Values and Specification</span>
0238 <span class="comment">% also precompute the structmask (bitmask that encodes which elements in Values are structs)</span>
0239 <span class="comment">% and split both the report_type, skip and nodefaults flags off from vals</span>
0240 <a name="_sub1" href="#_subfunctions" class="code">function [fmt,vals,compressed_spec,structmask,report_type,skip,nodefaults] = process_inputs(vals,compressed_spec)</a>
0241     skip = false;
0242     nodefaults = false;
0243     <span class="keyword">if</span> iscell(vals)
0244         <span class="comment">% no Format specifier was given: use default</span>
0245         fmt = [0 Inf];
0246     <span class="keyword">else</span>
0247         <span class="comment">% a Format specifier was given as first argument (need to shift remaining arguments by 1)</span>
0248         fmt = vals;
0249         vals = compressed_spec{1};
0250         compressed_spec(1) = [];
0251     <span class="keyword">end</span>
0252     
0253     <span class="comment">% extract report type</span>
0254     <span class="keyword">if</span> length(vals)&gt;1 &amp;&amp; isequal(vals{end-1},<span class="string">'__arg_report__'</span>)
0255         report_type = vals{end};
0256         <span class="comment">% check for some report types that can be handled immediately</span>
0257         <span class="keyword">switch</span> report_type
0258             <span class="keyword">case</span> <span class="string">'raw'</span>
0259                 <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(compressed_spec);
0260             <span class="keyword">case</span> <span class="string">'properties'</span>
0261                 <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(struct());
0262             <span class="keyword">case</span> {<span class="string">'lean'</span>,<span class="string">'rich'</span>}
0263                 <span class="keyword">if</span> length(vals) == 2
0264                     <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(hlp_microcache(<span class="string">'spec'</span>,@<a href="#_sub6" class="code" title="subfunction spec = expand_spec(spec,report_type,assign_defaults,caller_name)">expand_spec</a>,compressed_spec,report_type,true,determine_caller())); <span class="keyword">end</span>
0265             <span class="keyword">case</span> <span class="string">'handle'</span>
0266                 error(<span class="string">'To make function handles accessible, use the function expose_handles().'</span>);
0267             <span class="keyword">case</span> <span class="string">'supported'</span>
0268                 <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(true);
0269         <span class="keyword">end</span>
0270         vals(end-1:end) = [];
0271         
0272         <span class="comment">% check for nodefaults flag (do not apply defaults)</span>
0273         <span class="keyword">if</span> length(vals)&gt;1 &amp;&amp; isequal(vals{end-1},<span class="string">'__arg_nodefaults__'</span>)
0274             nodefaults = vals{end};
0275             vals(end-1:end) = [];
0276         <span class="keyword">end</span>
0277         
0278         <span class="comment">% check for skip flag (skip leading skippable args in positional argument lists)</span>
0279         <span class="keyword">if</span> length(vals)&gt;1 &amp;&amp; isequal(vals{end-1},<span class="string">'__arg_skip__'</span>)
0280             skip = vals{end};
0281             vals(end-1:end) = [];
0282         <span class="keyword">end</span>
0283 
0284     <span class="keyword">else</span>
0285         report_type = <span class="string">'none'</span>;
0286     <span class="keyword">end</span>
0287         
0288     <span class="comment">% if Format is a function, run it to reformat vals and fmt</span>
0289     <span class="keyword">if</span> isa(fmt,<span class="string">'function_handle'</span>)
0290         <span class="keyword">switch</span> nargin(fmt)
0291             <span class="keyword">case</span> 1
0292                 <span class="keyword">if</span> nargout(fmt) == 1
0293                     vals = feval(fmt,vals); 
0294                     fmt = 0;
0295                 <span class="keyword">else</span>
0296                     [vals,fmt] = feval(fmt,vals);
0297                 <span class="keyword">end</span>
0298             <span class="keyword">case</span> 2
0299                 <span class="comment">% first expand the spec</span>
0300                 tmpspec = hlp_microcache(<span class="string">'spec'</span>,@<a href="#_sub6" class="code" title="subfunction spec = expand_spec(spec,report_type,assign_defaults,caller_name)">expand_spec</a>,compressed_spec,<span class="string">'lean'</span>,~nodefaults,determine_caller());
0301                 <span class="comment">% then call the function with it</span>
0302                 <span class="keyword">if</span> nargout(fmt) == 1
0303                     vals = feval(fmt,vals,tmpspec);
0304                     fmt = 0;
0305                 <span class="keyword">else</span>
0306                     [vals,fmt] = feval(fmt,vals,tmpspec);
0307                 <span class="keyword">end</span>
0308             <span class="keyword">otherwise</span>
0309                 error(<span class="string">'The given formatting function expects an unsupported number of inputs (only 1 or 2 inputs supported).'</span>);
0310         <span class="keyword">end</span>            
0311         <span class="keyword">if</span> isa(fmt,<span class="string">'function_handle'</span>)
0312             error(<span class="string">'If a given formatting function returns a new format description as second output, that description must be numeric (e.g., [0 Inf] or 0).'</span>); <span class="keyword">end</span>
0313     <span class="keyword">end</span>
0314     
0315     <span class="comment">% get places where structs occur in the Values</span>
0316     structmask = cellfun(<span class="string">'isclass'</span>,vals,<span class="string">'struct'</span>);
0317 <span class="keyword">end</span>
0318 
0319 
0320 <span class="comment">% check if arg_define is being called in direct mode</span>
0321 <a name="_sub2" href="#_subfunctions" class="code">function direct_mode = is_direct_mode(vals,structmask)</a>
0322     <span class="keyword">if</span> length(vals)&gt;1 &amp;&amp; isequal(vals(end-1:end),{<span class="string">'arg_direct'</span>,true})
0323         direct_mode = true;
0324     <span class="keyword">elseif</span> ~isempty(vals) &amp;&amp; isfield(vals{end},<span class="string">'arg_direct'</span>)
0325         direct_mode = vals{end}.arg_direct;
0326     <span class="keyword">else</span>
0327         direct_mode = false;
0328         <span class="comment">% search for it</span>
0329         indices = find(structmask | strcmp(vals,<span class="string">'arg_direct'</span>));
0330         <span class="keyword">for</span> k = indices(end:-1:1)
0331             <span class="keyword">if</span> ischar(vals{k}) &amp;&amp; k&lt;length(vals)
0332                 <span class="comment">% found it in the NVPs</span>
0333                 direct_mode = vals{k+1};
0334                 <span class="keyword">break</span>;
0335             <span class="keyword">elseif</span> isfield(vals{k},<span class="string">'arg_direct'</span>)
0336                 <span class="comment">% found it in a struct</span>
0337                 direct_mode = vals{k}.arg_direct;
0338                 <span class="keyword">break</span>;
0339             <span class="keyword">end</span>
0340         <span class="keyword">end</span>
0341     <span class="keyword">end</span>
0342 <span class="keyword">end</span>
0343 
0344 
0345 <span class="comment">% directly assign names to values</span>
0346 <a name="_sub3" href="#_subfunctions" class="code">function [nvps,outstruct] = assign_direct(vals,structmask,make_struct)</a>
0347     <span class="keyword">if</span> make_struct
0348         <span class="comment">% the variables are returned in the outstruct</span>
0349         <span class="keyword">if</span> ~isscalar(structmask)
0350             <span class="comment">% obtain flat NVP list</span>
0351             nvps = flatten_structs(vals,structmask);
0352             <span class="comment">% split names/values and find indices of the last assignment for each name</span>
0353             nvps = reshape(nvps,2,[]);
0354             [s,indices] = sort(nvps(1,:));
0355             indices(strcmp(s(1:end-1),s(2:end))) = [];
0356             <span class="comment">% build &amp; return the struct</span>
0357             outstruct = cell2struct(nvps(2,indices),nvps(1,indices),2);
0358         <span class="keyword">else</span>
0359             <span class="comment">% a single struct was passed in: pass it right through</span>
0360             nvps = vals;
0361             outstruct = nvps{1};
0362         <span class="keyword">end</span>
0363     <span class="keyword">else</span>
0364         <span class="comment">% no output argument: generate NVP list for subsequent assignment to function workspace</span>
0365         nvps = flatten_structs(vals,structmask);
0366         outstruct = [];
0367     <span class="keyword">end</span>
0368 <span class="keyword">end</span>
0369 
0370 
0371 <span class="comment">% cached wrapper around process_spec</span>
0372 <a name="_sub4" href="#_subfunctions" class="code">function varargout = process_spec_cached(caller_name,spec,report_type,assign_defaults,perform_namecheck)</a>
0373     <span class="keyword">persistent</span> cache;
0374     caller_field = caller_name; 
0375     caller_field(~((caller_field&gt;=<span class="string">'a'</span>&amp;caller_field&lt;=<span class="string">'z'</span>) | (caller_field&gt;=<span class="string">'A'</span>&amp;caller_field&lt;=<span class="string">'Z'</span>) | (caller_field&gt;=<span class="string">'0'</span>&amp;caller_field&lt;=<span class="string">'9'</span>))) = <span class="string">'_'</span>;
0376     key = [report_type <span class="string">'a'</span>+assign_defaults];
0377     <span class="keyword">try</span>
0378         <span class="comment">% try to load the cached result for the given caller</span>
0379         result = cache.(caller_field).(key);
0380         <span class="comment">% return if it matches the current input</span>
0381         <span class="keyword">if</span> isequal(result.spec,spec) || isequalwithequalnans(result.spec,spec) <span class="comment">%#ok&lt;FPARK&gt;</span>
0382             varargout = result.output; 
0383             <span class="keyword">return</span>; 
0384         <span class="keyword">end</span>
0385     <span class="keyword">catch</span> <span class="comment">%#ok&lt;CTCH&gt;</span>
0386     <span class="keyword">end</span>
0387     <span class="comment">% otherwise fall back to microcache and overwrite</span>
0388     [varargout{1:nargout}] = hlp_microcache(<span class="string">'spec'</span>,@<a href="#_sub5" class="code" title="subfunction [spec,flat_names,first_names,name2idx,leading_skippable,checks] = process_spec(caller_name,compressed_spec,report_type,assign_defaults,perform_namecheck)">process_spec</a>,caller_name,spec,report_type,assign_defaults,perform_namecheck);
0389     cache.(caller_field).(key) = struct(<span class="string">'output'</span>,{varargout},<span class="string">'spec'</span>,{spec});
0390 <span class="keyword">end</span>
0391 
0392 
0393 <span class="comment">% expand a specification from a cell array into a struct array</span>
0394 <a name="_sub5" href="#_subfunctions" class="code">function [spec,flat_names,first_names,name2idx,leading_skippable,checks] = process_spec(caller_name,compressed_spec,report_type,assign_defaults,perform_namecheck)</a>
0395     
0396     <span class="comment">% expand the compressed cell-array spec into a full struct-array spec</span>
0397     spec = <a href="#_sub6" class="code" title="subfunction spec = expand_spec(spec,report_type,assign_defaults,caller_name)">expand_spec</a>(compressed_spec,<span class="string">'rich'</span>,assign_defaults,caller_name);
0398     
0399     <span class="comment">% obtain the argument names and a flat list thereof</span>
0400     arg_names = {spec.names};
0401     flat_names = [arg_names{:}];
0402     first_names = cellfun(@(n)n{1},arg_names,<span class="string">'UniformOutput'</span>,false);
0403 
0404     <span class="comment">% create a name/index remapping table</span>
0405     name2idx = struct();
0406     <span class="keyword">for</span> n=1:length(arg_names)
0407         <span class="keyword">for</span> k=1:length(arg_names{n})
0408             name2idx.(arg_names{n}{k}) = n; <span class="keyword">end</span>
0409     <span class="keyword">end</span>
0410     
0411     <span class="comment">% find the number of leading skippable arguments</span>
0412     leading_skippable = find(~[spec.skippable false],1)-1;
0413 
0414     <span class="comment">% check for duplicate argument names in the Specification</span>
0415     sorted_names = sort(flat_names);
0416     duplicates = unique(sorted_names(strcmp(sorted_names(1:end-1),sorted_names(2:end))));
0417     <span class="keyword">if</span> ~isempty(duplicates)
0418         error([<span class="string">'The names '</span> hlp_tostring(duplicates) <span class="string">' refer to multiple arguments.'</span>]); <span class="keyword">end</span>
0419     
0420     <span class="comment">% if required, check for name clashes with functions on the path</span>
0421     <span class="comment">% (this is due to a deficiency in MATLAB's handling of variables that were assigned to a</span>
0422     <span class="comment">% function's scope from a subfunction, which are prone to clashes with functions on the path...)</span>
0423     <span class="keyword">if</span> perform_namecheck &amp;&amp; strcmp(report_type,<span class="string">'none'</span>)
0424         <span class="keyword">try</span>
0425             validate_varnames(caller_name,first_names);
0426         <span class="keyword">catch</span> e
0427             disp_once(<span class="string">'The function validate_names failed; reason: %s'</span>,e.message);
0428         <span class="keyword">end</span>
0429     <span class="keyword">end</span>
0430     
0431     <span class="comment">% determine which checks are necessary</span>
0432     checks.mandatory = <a href="#_sub7" class="code" title="subfunction ismatch = check_property(spec,name,value)">check_property</a>(spec,<span class="string">'value'</span>,mandatory);
0433     checks.unassigned = <a href="#_sub7" class="code" title="subfunction ismatch = check_property(spec,name,value)">check_property</a>(spec,<span class="string">'value'</span>,unassigned);
0434     checks.expression = <a href="#_sub7" class="code" title="subfunction ismatch = check_property(spec,name,value)">check_property</a>(spec,<span class="string">'type'</span>,<span class="string">'expression'</span>);
0435     checks.conversion = <a href="#_sub7" class="code" title="subfunction ismatch = check_property(spec,name,value)">check_property</a>(spec,<span class="string">'to_double'</span>,true);
0436 <span class="keyword">end</span>
0437 
0438 
0439 <span class="comment">% expand the given spec cell array into a struct array</span>
0440 <a name="_sub6" href="#_subfunctions" class="code">function spec = expand_spec(spec,report_type,assign_defaults,caller_name)</a>
0441     <span class="comment">% evaluate the cells into specifier structs</span>
0442     <span class="keyword">if</span> all(cellfun(<span class="string">'isclass'</span>,spec,<span class="string">'cell'</span>))
0443         spec = cellfun(@(s)feval(s{1},report_type,s{2}{:}),spec); <span class="keyword">end</span>
0444     <span class="comment">% make sure that spec has the correct fields, even if empty</span>
0445     <span class="keyword">if</span> isempty(spec)
0446         spec = <a href="arg_specifier.html" class="code" title="function spec = arg_specifier(varargin)">arg_specifier</a>;
0447         spec = spec([]);
0448     <span class="keyword">end</span>
0449     <span class="comment">% optionally assign the default values</span>
0450     <span class="keyword">if</span> assign_defaults
0451         <span class="keyword">for</span> s=1:length(spec)
0452             <span class="keyword">for</span> def=spec(s).defaults
0453                 spec(s) = <a href="#_sub11" class="code" title="subfunction spec = assign_value(spec,newvalue,report_type,caller_name,nodefaults,deprecation_warning,respect_empty_overwrites)">assign_value</a>(spec(s),def{1},report_type,caller_name,false,false,false); <span class="keyword">end</span>
0454         <span class="keyword">end</span>
0455     <span class="keyword">end</span>    
0456 <span class="keyword">end</span>
0457 
0458 
0459 <span class="comment">% recursively check whether the given property is set to the given value in any of the spec entries</span>
0460 <a name="_sub7" href="#_subfunctions" class="code">function ismatch = check_property(spec,name,value)</a>
0461     <span class="keyword">if</span> isempty(spec)
0462         ismatch = false;
0463     <span class="keyword">else</span>
0464         <span class="keyword">if</span> ischar(value)
0465             ismatch = any(strcmp({spec.(name)},value));
0466         <span class="keyword">elseif</span> isscalar(value) &amp;&amp; islogical(value)
0467             ismatch = any([spec.(name)]==value);
0468         <span class="keyword">else</span>
0469             ismatch = any(cellfun(@(x)isequal(x,value),{spec.(name)}));
0470         <span class="keyword">end</span>
0471         <span class="keyword">if</span> ~ismatch
0472             <span class="keyword">for</span> k=find(~cellfun(<span class="string">'isempty'</span>,{spec.children}))
0473                 ismatch = <a href="#_sub7" class="code" title="subfunction ismatch = check_property(spec,name,value)">check_property</a>(spec(k).children,name,value);
0474                 <span class="keyword">if</span> ismatch
0475                     <span class="keyword">return</span>; <span class="keyword">end</span>
0476             <span class="keyword">end</span>
0477             <span class="keyword">for</span> k=find(~cellfun(<span class="string">'isempty'</span>,{spec.alternatives}))
0478                 ismatch = <a href="#_sub7" class="code" title="subfunction ismatch = check_property(spec,name,value)">check_property</a>([spec(k).alternatives{:}],name,value);
0479                 <span class="keyword">if</span> ismatch
0480                     <span class="keyword">return</span>; <span class="keyword">end</span>            
0481             <span class="keyword">end</span>
0482         <span class="keyword">end</span>
0483     <span class="keyword">end</span>
0484 <span class="keyword">end</span>
0485 
0486 
0487 <span class="comment">% transform the cell array of input arguments (vals) to a pure list of name-value pairs (NVPs)</span>
0488 <a name="_sub8" href="#_subfunctions" class="code">function nvps = arguments_to_nvps(caller_name,fmt,vals,structmask,flat_names,first_names,skipped_positionals,suppress_warnings_for)</a>
0489     permitted_names = [flat_names {<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>}];
0490     
0491     <span class="comment">% get the call signature; this is vals with everything replaced by [] that is neither a valid argument</span>
0492     <span class="comment">% name nor a struct, and structs replaced by a sorted cell array of their field names</span>
0493     charmask = cellfun(<span class="string">'isclass'</span>,vals,<span class="string">'char'</span>);
0494     signature = vals;
0495     signature(~(charmask|structmask)) = {[]};
0496     <span class="keyword">for</span> k=find(charmask)
0497         <span class="keyword">if</span> ~any(strcmp(signature{k},permitted_names))
0498             signature{k} = sprintf(<span class="string">'%u'</span>,k); <span class="keyword">end</span>
0499     <span class="keyword">end</span>
0500     <span class="keyword">if</span> any(structmask)
0501         signature(structmask) = cellfun(@fieldnames,signature(structmask),<span class="string">'UniformOutput'</span>,false); <span class="keyword">end</span>
0502     
0503     <span class="comment">% determine the number n of arguments that were specified positionally</span>
0504     caller_field = caller_name; 
0505     caller_field(~((caller_field&gt;=<span class="string">'a'</span>&amp;caller_field&lt;=<span class="string">'z'</span>) | (caller_field&gt;=<span class="string">'A'</span>&amp;caller_field&lt;=<span class="string">'Z'</span>) | (caller_field&gt;=<span class="string">'0'</span>&amp;caller_field&lt;=<span class="string">'9'</span>))) = <span class="string">'_'</span>;
0506     [n,violations,ignored] = hlp_nanocache(caller_field,10,@<a href="#_sub9" class="code" title="subfunction [num_positionals,violations,ignored] = get_num_positionals(fmt,spec_length,signature,structmask,permitted_names,skipped_positionals)">get_num_positionals</a>,fmt,length(first_names),signature,structmask,permitted_names,skipped_positionals);
0507     
0508     <span class="comment">% emit errors and/or diagnostic warnings</span>
0509     <span class="keyword">if</span> isnan(n)
0510         <span class="keyword">for</span> k=find(cellfun(@(s)all(s&gt;=<span class="string">'0'</span>&amp;s&lt;=<span class="string">'9'</span>),violations))
0511             violations{k} = vals{str2num(violations{k})}; <span class="keyword">end</span> <span class="comment">%#ok&lt;ST2NM&gt;</span>
0512         <span class="keyword">if</span> length(violations) == 1
0513             <span class="comment">% if there's only one violation (e.g., typo) generate a suggestion</span>
0514             mindist = Inf;
0515             suggestion = <span class="string">''</span>;
0516             <span class="keyword">for</span> k=1:length(flat_names)
0517                 dist = strdist(flat_names{k},violations{1});
0518                 <span class="keyword">if</span> dist &lt; mindist
0519                     mindist = dist;
0520                     suggestion = flat_names{k};
0521                 <span class="keyword">end</span>
0522             <span class="keyword">end</span>
0523             error(<span class="string">'arg_define:invalid_arguments'</span>,<span class="string">'An argument with name %s does not appear in the argument specification; did you mean %s?'</span>,violations{1},suggestion);
0524         <span class="keyword">else</span>
0525             error(<span class="string">'arg_define:invalid_arguments'</span>,<span class="string">'Some of the specified arguments do not appear in the argument specification; %s.'</span>,hlp_tostring(violations));
0526         <span class="keyword">end</span>
0527     <span class="keyword">else</span>
0528         ignored = fast_setdiff(ignored,suppress_warnings_for);
0529         <span class="keyword">if</span> ~isempty(ignored)
0530             <span class="keyword">for</span> k=find(cellfun(@(s)all(s&gt;=<span class="string">'0'</span>&amp;s&lt;=<span class="string">'9'</span>),violations))
0531                 violations{k} = vals{str2num(violations{k})}; <span class="keyword">end</span> <span class="comment">%#ok&lt;ST2NM&gt;</span>
0532             <span class="comment">% warn about possible parameter conflicts (unless the parameter in question is called data</span>
0533             <span class="comment">% or srate, and the passed in object matches the signature of an EEGLAB dataset struct)</span>
0534             warn_once(<span class="string">'arg_define:possible_conflict'</span>,<span class="string">'arg_define() in %s: Possible parameter conflict -- both unrecognized parameters %s and matching names %s passed in. Assuming that the function is called with %u positional arguments. This warning will not be repeated for this MATLAB session.'</span>,caller_name,hlp_tostring(violations),hlp_tostring(ignored),n);
0535         <span class="keyword">end</span>
0536     <span class="keyword">end</span>
0537     
0538     <span class="comment">% generate a flat list of name-value pairs</span>
0539     <span class="keyword">if</span> n
0540         <span class="comment">% optionally pad vals with implicit []'s for each positional to skip</span>
0541         <span class="keyword">if</span> skipped_positionals
0542             vals = [repmat({[]},1,skipped_positionals) vals]; <span class="keyword">end</span>
0543         <span class="comment">% prepend the positionals and their associated names</span>
0544         nvps = [reshape([first_names(1:n);vals(1:n)],1,[]) flatten_structs(vals(n+1:end),structmask(n+1:end))];
0545     <span class="keyword">elseif</span> any(structmask)
0546         nvps = flatten_structs(vals,structmask);
0547     <span class="keyword">else</span>
0548         nvps = vals;
0549     <span class="keyword">end</span>
0550 <span class="keyword">end</span>
0551 
0552 
0553 <span class="comment">% determine the number of positional arguments in a given call signature</span>
0554 <a name="_sub9" href="#_subfunctions" class="code">function [num_positionals,violations,ignored] = get_num_positionals(fmt,spec_length,signature,structmask,permitted_names,skipped_positionals)</a>
0555     violations = {};
0556     ignored = {};
0557     <span class="keyword">if</span> ischar(fmt) &amp;&amp; strcmp(fmt,<span class="string">'allow-unlisted-names'</span>)
0558         num_positionals = 0;
0559     <span class="keyword">else</span>        
0560         num_positionals = NaN;
0561         
0562         <span class="comment">% preprocess fmt</span>
0563         max_positionals = min(spec_length,length(signature)+skipped_positionals);
0564         <span class="keyword">if</span> isempty(fmt)
0565             <span class="comment">% empty Format means that any number of positionals are permitted</span>
0566             fmt = 0:max_positionals;
0567         <span class="keyword">else</span>
0568             <span class="comment">% make sure that 0 positional arguments are always permitted</span>
0569             <span class="keyword">if</span> ~any(fmt==0)
0570                 fmt = [0 fmt]; <span class="keyword">end</span>
0571             <span class="comment">% remap Inf to the max # of positionals</span>
0572             fmt(fmt==Inf) = max_positionals;
0573             <span class="comment">% remove anything else that is out of bounds</span>
0574             fmt(fmt&gt;max_positionals | fmt&lt;0) = [];
0575             <span class="comment">% make sure that it is sorted and contains no duplicates</span>
0576             fmt = unique(sort(fmt));
0577         <span class="keyword">end</span>
0578 
0579         <span class="comment">% replace the cell arrays in the signature by dummy structs, so we can use flatten_structs</span>
0580         <span class="keyword">for</span> k=find(structmask)
0581             signature{k} = cell2struct(cell(1,length(signature{k})),signature{k},2); <span class="keyword">end</span>
0582 
0583         <span class="comment">% for each permitted number of positional arguments n in fmt...</span>
0584         <span class="keyword">for</span> n = fmt <span class="comment">%#ok&lt;*ALIGN&gt;</span>
0585             <span class="keyword">if</span> skipped_positionals &amp;&amp; length(fmt)&gt;1 &amp;&amp; n==fmt(2)
0586                 <span class="comment">% pad the signature with dummy positionals if num_skippable is nonzero</span>
0587                 signature = [repmat({[]},1,skipped_positionals) signature]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0588                 structmask = [false(1,skipped_positionals) structmask]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0589             <span class="keyword">end</span>
0590             <span class="comment">% interpret the arguments after the first n positions als NVPs/structs</span>
0591             nvps = flatten_structs(signature(n+1:end),structmask(n+1:end));
0592             <span class="comment">% perform type check</span>
0593             <span class="keyword">if</span> iscellstr(nvps(1:2:end))
0594                 <span class="comment">% make sure that only admissible names are used</span>
0595                 inadmissible = fast_setdiff(nvps(1:2:end),permitted_names);
0596                 <span class="keyword">if</span> isempty(inadmissible)
0597                     <span class="comment">% NVP arguments are all admissible: use this as num_positionals</span>
0598                     num_positionals = n;                
0599                     <span class="keyword">if</span> n&gt;0
0600                         <span class="comment">% assuming n positional arguments; collect any admissible names among those, i.e.,</span>
0601                         <span class="comment">% names that would have been valid argument names but were ignored</span>
0602                         fmt(fmt&gt;=n) = [];
0603                         <span class="keyword">for</span> k=fmt
0604                             nvps = flatten_structs(signature(k+1:n),structmask(k+1:n));
0605                             <span class="keyword">if</span> iscellstr(nvps(1:2:end))
0606                                 ignored = [ignored intersect(nvps(1:2:end),permitted_names)]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0607                             <span class="keyword">else</span>
0608                                 ignored = [ignored intersect(nvps(cellfun(<span class="string">'isclass'</span>,nvps,<span class="string">'char'</span>)),permitted_names)]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0609                             <span class="keyword">end</span>
0610                         <span class="keyword">end</span>
0611                         ignored = unique(ignored);
0612                     <span class="keyword">end</span>                
0613                     violations = unique(violations);
0614                     <span class="keyword">return</span>;
0615                 <span class="keyword">else</span>
0616                     <span class="comment">% inadmissible names: collect diagnostic information</span>
0617                     violations = [violations inadmissible]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0618                 <span class="keyword">end</span>
0619             <span class="keyword">else</span>
0620                 violations = [violations {<span class="string">'invalid sequence of names and structs'</span>}]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0621             <span class="keyword">end</span>
0622         <span class="keyword">end</span>
0623         violations = unique(violations);
0624     <span class="keyword">end</span>
0625 <span class="keyword">end</span>
0626 
0627 
0628 <span class="comment">% assign the values in an NVP list to the spec</span>
0629 <a name="_sub10" href="#_subfunctions" class="code">function spec = assign_nvps(spec,nvps,name2idx,report_type,caller_name,deprecation_warning)</a>
0630     <span class="keyword">if</span> ~strcmp(report_type,<span class="string">'rich'</span>)
0631         report_type = <span class="string">'lean'</span>; <span class="keyword">end</span>
0632     <span class="keyword">for</span> k=1:2:length(nvps)
0633         <span class="keyword">try</span> 
0634             idx = name2idx.(nvps{k});
0635         <span class="keyword">catch</span>
0636             <span class="comment">% this is an internal sanity check; if this message is triggered some internal error has</span>
0637             <span class="comment">% occurred</span>
0638             <span class="keyword">if</span> any(strcmp({spec.first_name},nvps{k}))
0639                 error([<span class="string">'Cannot insert a duplicate field into the specification: '</span> nvps{k}]); <span class="keyword">end</span>
0640             <span class="comment">% append it to the spec</span>
0641             spec(end+1) = <a href="cached_argument.html" class="code" title="function result = cached_argument(name,default)">cached_argument</a>(nvps{k},nvps{k+1}); <span class="comment">%#ok&lt;AGROW&gt;</span>
0642             name2idx.(nvps{k}) = length(spec);
0643             <span class="keyword">continue</span>;
0644         <span class="keyword">end</span>
0645         spec(idx) = <a href="#_sub11" class="code" title="subfunction spec = assign_value(spec,newvalue,report_type,caller_name,nodefaults,deprecation_warning,respect_empty_overwrites)">assign_value</a>(spec(idx),nvps{k+1},report_type,caller_name,true,deprecation_warning,true);
0646     <span class="keyword">end</span>
0647 <span class="keyword">end</span>
0648 
0649 
0650 <span class="comment">% assign a given value to a single element in a spec</span>
0651 <a name="_sub11" href="#_subfunctions" class="code">function spec = assign_value(spec,newvalue,report_type,caller_name,nodefaults,deprecation_warning,respect_empty_overwrites)</a>
0652     skip_arg = {<span class="string">'__arg_skip__'</span>,true};
0653     nodefault_arg = {<span class="string">'__arg_nodefaults__'</span>,true};
0654     <span class="comment">% check whether this value is assignable</span>
0655     overwrite_if_empty = spec.empty_overwrites || ~respect_empty_overwrites;
0656     <span class="keyword">if</span> ~isequal(newvalue,<span class="string">'__arg_unassigned__'</span>) &amp;&amp; ~(~overwrite_if_empty &amp;&amp; (isequal(newvalue,[]) || isequal(newvalue,<span class="string">'__arg_mandatory__'</span>)))
0657         <span class="comment">% warn about deprecation</span>
0658         <span class="keyword">if</span> deprecation_warning &amp;&amp; spec.deprecated &amp;&amp; ~isequal_weak(spec.value,newvalue)
0659             <a href="#_sub13" class="code" title="subfunction warn_deprecation(spec,caller_name)">warn_deprecation</a>(spec,caller_name); <span class="keyword">end</span>
0660         <span class="comment">% perform assignment</span>
0661         <span class="keyword">if</span> isempty(spec.mapper)
0662             <span class="keyword">try</span>
0663                 <a href="#_sub12" class="code" title="subfunction check_value(spec,newvalue,caller_name)">check_value</a>(spec,newvalue,caller_name);
0664             <span class="keyword">catch</span>
0665                 <span class="comment">% got a check error: make sure that the value is not a search</span>
0666                 <span class="comment">% range (in which case we would let it pass)</span>
0667                 <span class="keyword">if</span> ~(all(isfield(newvalue,{<span class="string">'head'</span>,<span class="string">'parts'</span>})) &amp;&amp; strcmp(char(newvalue.head),<span class="string">'search'</span>))
0668                     <span class="comment">% check the new value again to propagate the previous error properly</span>
0669                     <a href="#_sub12" class="code" title="subfunction check_value(spec,newvalue,caller_name)">check_value</a>(spec,newvalue,caller_name);
0670                 <span class="keyword">end</span>
0671             <span class="keyword">end</span>
0672             spec.value = newvalue;
0673         <span class="keyword">else</span>
0674             <span class="comment">% apply the mapper to get the selection key and the value pack</span>
0675             [key,value] = spec.mapper(newvalue,spec.range,spec.names);
0676             spec.value = key;
0677             <span class="keyword">if</span> isempty(key)
0678                 <span class="comment">% arg_sub</span>
0679                 pos = 1;
0680                 source_fields = spec.children;
0681             <span class="keyword">elseif</span> islogical(key) || isnumeric(key)
0682                 <span class="comment">% arg_subtoggle</span>
0683                 pos = key+1;
0684                 source_fields = spec.alternatives{pos};
0685             <span class="keyword">elseif</span> ischar(key)
0686                 <span class="comment">% arg_subswitch</span>
0687                 pos = find(strcmp(key,spec.range));
0688                 source_fields = spec.alternatives{pos};
0689             <span class="keyword">else</span>
0690                 error(<span class="string">'Unsupported mapper key class.'</span>);
0691             <span class="keyword">end</span>                        
0692 
0693             <span class="comment">% parse the value into a spec struct array</span>
0694             <span class="keyword">if</span> isequal(key,false)
0695                 spec.value = false;
0696                 spec.children = <a href="cached_argument.html" class="code" title="function result = cached_argument(name,default)">cached_argument</a>(<span class="string">'arg_selection'</span>,false);
0697             <span class="keyword">else</span>
0698                 <span class="keyword">if</span> nodefaults
0699                     <span class="comment">% parse the value into a spec, without returning defaults</span>
0700                     value = <a href="arg_report.html" class="code" title="function result = arg_report(type,func,args)">arg_report</a>(report_type,spec.sources{pos},[value skip_arg nodefault_arg]);
0701                     <span class="comment">% selectively override the current source fields with the parsed value</span>
0702                     spec.children = override_fields(source_fields,value);
0703                 <span class="keyword">else</span>
0704                     <span class="comment">% replace the children by the result</span>
0705                     spec.children = <a href="arg_report.html" class="code" title="function result = arg_report(type,func,args)">arg_report</a>(report_type,spec.sources{pos},[value skip_arg]);
0706                 <span class="keyword">end</span>
0707                 <span class="comment">% override flags</span>
0708                 spec.children = override_flags(spec.children,spec.reflag{pos}{:});
0709                 <span class="keyword">if</span> ~isempty(key)
0710                     <span class="comment">% make sure that arg_selection child is included &amp; set</span>
0711                     <span class="keyword">if</span> ~isempty(spec.children)
0712                         selection_arg = strcmp(<span class="string">'arg_selection'</span>,{spec.children.first_name});
0713                         <span class="keyword">if</span> any(selection_arg)
0714                             spec.children(selection_arg).value = key;
0715                         <span class="keyword">else</span>
0716                             spec.children = [spec.children,<a href="cached_argument.html" class="code" title="function result = cached_argument(name,default)">cached_argument</a>(<span class="string">'arg_selection'</span>,key)];
0717                         <span class="keyword">end</span>
0718                     <span class="keyword">else</span>
0719                         spec.children = <a href="cached_argument.html" class="code" title="function result = cached_argument(name,default)">cached_argument</a>(<span class="string">'arg_selection'</span>,key);
0720                     <span class="keyword">end</span>
0721                     <span class="comment">% update alternatives</span>
0722                     spec.alternatives{pos} = spec.children; 
0723                 <span class="keyword">end</span>
0724             <span class="keyword">end</span>
0725         <span class="keyword">end</span>
0726     <span class="keyword">end</span>
0727 <span class="keyword">end</span>
0728 
0729 <a name="_sub12" href="#_subfunctions" class="code">function check_value(spec,newvalue,caller_name)</a>
0730     <span class="comment">% no checks for arguments of type 'expression'</span>
0731     <span class="keyword">if</span> ~strcmp(spec.type,<span class="string">'expression'</span>)
0732         <span class="keyword">if</span> spec.typecheck
0733             check_type(spec.type,newvalue,spec.first_name,caller_name,spec.range); <span class="keyword">end</span>
0734         <span class="keyword">if</span> spec.shapecheck
0735             check_shape(spec.shape,newvalue,spec.first_name,caller_name); <span class="keyword">end</span>
0736         <span class="keyword">if</span> spec.rangecheck
0737             check_range(spec.range,newvalue,spec.first_name,caller_name); <span class="keyword">end</span>
0738     <span class="keyword">end</span>
0739 <span class="keyword">end</span>
0740 
0741 
0742 <span class="comment">% emit a deprecation warning</span>
0743 <a name="_sub13" href="#_subfunctions" class="code">function warn_deprecation(spec,caller_name)</a>
0744     <span class="keyword">if</span> iscell(spec.help)
0745         <span class="keyword">if</span> length(spec.help) == 1
0746             help = spec.help{1};
0747         <span class="keyword">else</span>
0748             help = [spec.help{1} <span class="string">'.'</span> spec.help{2}];
0749         <span class="keyword">end</span>
0750     <span class="keyword">else</span>
0751         help = spec.help;
0752     <span class="keyword">end</span>
0753     <span class="keyword">if</span> length(spec.names) &gt; 1
0754         name = [spec.names{1} <span class="string">'/'</span> spec.names{2}];
0755     <span class="keyword">else</span>
0756         name = spec.names{1};
0757     <span class="keyword">end</span>
0758     disp_once([<span class="string">'Using deprecated argument &quot;'</span> name <span class="string">'&quot; in function '</span> caller_name <span class="string">' (help: '</span> help <span class="string">').'</span>]); 
0759 <span class="keyword">end</span></pre></div>

<hr><address>Generated on Wed 19-Aug-2015 18:06:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>