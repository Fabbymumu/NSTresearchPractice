<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of exp_beginfun</title>
  <meta name="keywords" content="exp_beginfun">
  <meta name="description" content="Begin the definition of a function with lazy evaluation behavior.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">expressions</a> &gt; exp_beginfun.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/expressions&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>exp_beginfun

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Begin the definition of a function with lazy evaluation behavior.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function should_evaluate = exp_beginfun(setting, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Begin the definition of a function with lazy evaluation behavior.
 Evaluate = exp_beginfun(AttributeSetting, Attributes...)

 General
 =======
 If a function uses exp_beginfun/exp_endfun, MATLAB code that uses these functions does not &quot;call&quot;
 them in an imperative manner, but instead builds symbolic expressions that can be stored,
 transmitted, or manipulated before/if they are being evaluated. Evaluation is generally done via
 exp_eval() (or exp_eval_optimized()). Almost all uses of exp_beginfun by functions look like this:

   function [res1,res2,...] = my_function(arg1,arg2, ...)
   if ~exp_beginfun('somesetting') return; end

   ... &lt;actual implementation&gt; ...

   exp_endfun;
 
 ... where 'somesetting' specifies the behavioral setting for the function. Generally, all
 functions that operate on data sets and modify the signal content in a way that needs to be
 replicated online have the setting 'filter', and all functions that have no equivalent during
 online processing (e.g., marker transcription) have the setting 'editing'. Functions that do
 processing that cannot be reproduced online have the setting 'offline'. See filters/flt_* and
 dataset_ops/set_* for some examples. A setting is a shortcut name for an assignment of attributes
 associated with the function declaration (attributes can also be directly specified to
 exp_beginfun).


 Filter and Editing Functions
 ============================
 Functions of type 'filter' should be written just like regular EEGLAB signal processing functions
 (i.e., they receive a data set and some options, and produce a transformed version of the data
 set), but functions that are supposed to be usable online should be &quot;chunkable&quot;, i.e. they should
 produce the same sequence of output samples when they are called for consecutive segments (chunks)
 of the data set. Thus, the function should dump its internal state in an additional output (the
 'state' variable) and be able to resume from this state when called on the next chunk. Chunks may
 well be just a single sample long. During online processing, state will be passed in automatically.

 In some cases, this strict behavior would be prohibitively inefficient - in this case, the
 function may refrain to non-adaptive behavior if the chunks are too short. In particular, in
 BCILAB, it may be assumed that each filter is first called on a complete calibration data set in a
 single call, and is then either called on a complete test data set in one call (the next 'chunk'),
 or piecemeal on small blocks of an incoming online stream. ICA, for example, adapts itself only on
 the calibration data set (i.e. the first chunk) and uses that decomposition for all remaining ones
 (i.e. during online use).

 Functions of type 'editing' should be written just like regular EEGLAB data set editing functions
 (e.g. pop_chanedit), BUT they must not change the data or srate fields.

 Rationale/Background
 ====================
 For the purpose of data processing function declarations, the exp_beginfun/exp_endfun contract
 handles the book-keeping necessary to be able to reproduce the filter (and entire filter chain)
 1:1 online, and offers additional functionality, such as transparent caching of results (for later
 near-instantaneuous retrieval) and the annotation of all data sets with an executable expression
 which, when invoked, reproduces the data set 1:1, as well as checks to guarantee that no invalid
 &quot;tampering&quot; is done by the user on data sets (such as running a forward-backward filter in EEGLAB 
 or manually scaling the data). 

 In its general form, the functions exp_beginfun/exp_endfun are part of the machinery that enables
 symbolic computation in MATLAB (in the style of Mathematica), and the
 'filter'/'editing'/'symbolic'/'annotate'/'default' argument is a short-cut which selects default
 attributes of the function being defined (which can be overridden). Some of these attributes are
 customizable plugin &quot;slots&quot; (plugins to be applied to each argument or all inputs or all outputs
 of the function being defined). 'Filter'/'editing' imply such hooks as default attributes, which
 in turn implement the tamper-proofing checks and some post-processing on the emitted data sets.
 The post-processing adds fields (subfields of the .tracking field) to the (otherwise arbitrary)
 data set structs that are produced by the function being defined, most importantly the
 .tracking.expression, which is an executable (recursive) expression representation which mirrors
 each data set in symbolic form, and .tracking.online_expression, in the case of filters, which
 defines the arguments to be used for the respective filter during online processing. These
 operations are usually completely transparent to the user (and locked away in the .tracking
 field), and make it exceptionally simple to author components for the toolbox.

 The symbolic-computation functionality implemented by the expressions/exp_* functions is largely
 non-overlapping with what the MATLAB Symbolic toolbox offers: the Symbolic toolbox exclusively
 implements mathematics (e.g. derivatives, integrals, simplifications), while the expression system
 of BCILAB exclusively implements expression manipulation, such as substitution, pattern matching,
 hashing, memoization, and reflection. These facilities allow to implement very high-level behavior
 in functions such as bci_train, such as generic programming (e.g. utl_crossval, utl_searchmodel,
 utl_gridsearch being non-intrusively adapted to EEG sets, STUDY sets, etc.), optimizations (e.g.
 in-memory caching and on-disk caching of intermediate results, computational shortcuts, and more
 in the future), with relatively little coding effort.

 While, by default, a function is invoked online with the same parameters that were used for
 offline processing (aside from a 'state' parameter for stateful functions), it is is possible to
 specify that certain parameters should have different values during online processing. This is
 enabled by the attribute 'append_online' (list of arguments to be appended in the online case),
 which can be specified either to exp_beginfun or exp_endfun. Alternatively, the entire expression
 can be subsituted by setting the 'set_online' attribute (expression to use during online
 processing).

 In:
  AttributeSetting: baseline attribute assignment for the function; must be specified. Below are
                    typical scenarios:
                    * defining a function that should not evaluate immediately, but only after
                      evaluation by an exp_eval() clause:
                      'default' : delayed execution, input fingerprint checks

                    * defining a function that processes data sets and should have
                      delayed-evaluation semantics:
                      'filter'  : functions that do non-trivial processing of data sets, and which
                                  should support online replication of some offline processing;
                                  attributes: delayed (1), add_impure (1), set_online
                                  ('reproduce'), also performs EEGLAB-aware input data set checks &amp;
                                  transforms note: when an offline processing is replicated online,
                                  the function is called successively on short EEGLAB data sets,
                                  with inputs identical to the input parameters as they were
                                  snapshot after execution of the function's body (by exp_endfun)
                      'editing' : functions that do processing of data sets which has no equivalent
                                  in online processing, i.e. which pass the input data through
                                  unmodified; attributes: delayed (1), add_impure (1), set_online
                                  ('passthrough'), also performs EEGLAB-aware input data set checks
                      'offline' : functions that do processing of data sets which cannot be
                                  reproduced online; these generate an error, when used within
                                  online BCIss; attributes: delayed (1), add_impure (1), set_online
                                  ('inapplicable'), also performs EEGLAB-aware input data set
                                  checks

                    * definining a function that imports or constructs data sets from scratch:
                      'import'  : functions that construct a data set from scratch based on
                                  arguments that are not data sets

                    * defining a function that performs purely symbolic manipulations of
                      expressions:
                      'symbolic': all inputs are held unevaluated, associated (impure) values are
                                  ignored (thus no fingerprinting and no memoization); attributes:
                                  delayed (1), hold ('all'), fingerprints unchecked &amp; passed
                                  through, memoize (0)
                                  note: symbolic functions cannot be used in online code.

                    * defining a function that performs immediate (non-lazy) processing of data
                      structures, and which shall have their results annotated with an executable
                      (repeatable) description of the processing performed:
                      'annotate': delayed (0), add_impure (1)


   Attributes... : optional name-value pairs to refine attributes of the function being defined:

                     'delayed'   : whether the function has delayed-evaluation semantics, i.e. it 
                                   doesn't evaluate unless passed to exp_eval (default: 1)

                     'hold'      : []/'all'/'first'/'rest'; whether to leave all/the first/the
                                   remaining arguments or no arguments of the function unevaluated
                                   before executing the function body (useful for higher-order
                                   functions), (default: [])

                     'symbolic'  : whether the function being defined should be evaluated even if it
                                   receives unevaluated expressions as arguments (ignoring those
                                   arguments that fall under hold) - this is for symbol-manipulating
                                   functions that can process unevaluated expressions (0/1, default: 0)

                     'add_impure': integrate the original expression into the function value (when
                                   evaluated), creating an 'impure expression', 0/1

                     'set_online': Relevant only when the settings attribute is 'filter', 'editing'
                                   or 'offline', may also be specified in exp_endfun. Introduces an
                                   'online expression' into the function value (when evaluated),
                                   which is a record of how the resulting data (usually a signal)
                                   should be calculated online. Usually, this is identical to how
                                   the filter is applied offline.
                                   * 'passthrough': the function is skipped in the online
                                                    processing
                                   * 'reproduce': the function is called online with the same arguments
                                                  as in offline processing
                                   * 'inapplicable': the function gives an error when used in
                                                     online processing
                                   * {arg1, arg2, arg3, ...}: the given arguments will be used as
                                                              function arguments during online use
                                   * expression: the given expression will be used during online
                                                 reproduction of the filter

                     'append_online' : {arg1, arg2, arg3, ...}: the given arguments will be
                                       appended to the function arguments during online use
                                       (default: [])

                     'argsteps', 'presteps', 'poststeps' : advanced attributes, see also &quot;Advanced
                                                           Functionality&quot; section.

                     'delayed_online' : whether this function has delayed-evaluation semantics
                                        during online processing (default: false)

 Out:
   Evaluate     : whether the body of the function being defined shall be evaluated or skipped


 Advanced functionality:
   The allowed settings are customizable/extensible via the function <a href="exp_settings.html" class="code" title="function defaults = exp_settings(setting)">exp_settings</a>, which maps a
   setting string onto a cell array of default attributes (name-value pairs).

   During evaluation, each input argument is sent though a customizable sequence of functions,
   which can be specified via the 'argsteps' attribute (as a cell array). Further, the attriutes
   'presteps' and 'poststeps' are cell arrays of functions that should be invoked before and after
   the function body runs, respectively; they operate on a context structure, which is defined
   further below. These built-in attributes are the primary mechanism by which custom <a href="exp_settings.html" class="code" title="function defaults = exp_settings(setting)">exp_settings</a>
   add functionality to exp_beginfun/exp_endfun (e.g., annotating a dataset with an expression or
   checking fingerprints).

   The function's behavior can be controlled via dynamically scoped variables, as set by <a href="exp_block.html" class="code" title="function res = exp_block(rules, expr, iters)">exp_block</a>,
   <a href="exp_set.html" class="code" title="function res = exp_set(lhs,rhs) %#ok<STOUT>">exp_set</a> and <a href="exp_setdelayed.html" class="code" title="function res = exp_setdelayed(lhs,rhs) %#ok<STOUT>">exp_setdelayed</a>, or correspondent attributes in <a href="exp_beginfun.html" class="code" title="function should_evaluate = exp_beginfun(setting, varargin)">exp_beginfun</a>.
     These variables can be assigned values, such as 0/1, but may be arbitrary expressions
      * fingerprint_check: toggle per-argument fingerprint checking (default: true) - may use
        @expression to refer to the argument expression, to implement expression-dependent checking
      * fingerprint_create: toggle fingerprint creation (default: true) - may use @expression to
        refer to the unevaluated complete expression, to implement expression-dependent checking
      * memoize: selectively enable memoization; this is a cell array of the form
        {location,expression,location,expression, ...}. location can be either 'disk' or 'memory',
        expression should evaluate to true/false, may use @expression to refer to the unevaluated
        complete expression, to implement expression-dependent memoization.

 See also:
   <a href="exp_endfun.html" class="code" title="function exp_endfun(varargin)">exp_endfun</a>, <a href="exp_eval.html" class="code" title="function varargout = exp_eval(x,iters)">exp_eval</a>, <a href="exp_settings.html" class="code" title="function defaults = exp_settings(setting)">exp_settings</a>

 Examples:
   % a typical function declaration using the expression system
   function result = myfunc(myarg,myotherarg,yetanotherarg)
   if ~exp_beginfun('somesetting'), return; end
   ...
   <a href="exp_endfun.html" class="code" title="function exp_endfun(varargin)">exp_endfun</a>;


   % define a filter function using the expression system
   % (note that, for filters to work with all BCILAB facilities, the varargin arguments should also
   %  be processed via arg_define)
   function signal = flt_myfilter(varargin)
   if ~exp_beginfun('filter'), return; end
   ...
   <a href="exp_endfun.html" class="code" title="function exp_endfun(varargin)">exp_endfun</a>;


   % as before, but define that the filter, when applied during online processing, should be passed
   % a particular list of additional arguments
   function signal = flt_myfilter(varargin)
   if ~exp_beginfun('filter'), return; end
   ...
   exp_endfun('add_online',{'myinternalarg',10, 'my_reserved_argument','test'})


   % like before, but this time replace the entire set of arguments; the assumption here is that
   % the variable called signal contains the input signal, and that it can be passed to flt_myfilter
   % by name
   function signal = flt_myfilter(varargin)
   if ~exp_beginfun('filter'), return; end
   ...
   exp_endfun('set_online',{'signal',signal, 'myparam',10,'myotherparam',200})


   % like before, but this time define that the filter, when applied online, should go through an
   % entirely different function (here assumed to be defined using <a href="exp_beginfun.html" class="code" title="function should_evaluate = exp_beginfun(setting, varargin)">exp_beginfun</a> itself) with specific
   % arguments
   function signal = flt_myfilter(varargin)
   if ~exp_beginfun('filter'), return; end
   ...
   exp_endfun('set_online',flt_myfilter_online('signal',signal, 'specialparam1',10))


   % define a dataset editing function
   function signal = set_myoperation(varargin)
   if ~exp_beginfun('editing'), return; end
   ...
   <a href="exp_endfun.html" class="code" title="function exp_endfun(varargin)">exp_endfun</a>;


   % define a function that operates on expressions symbolically
   function result = my_operation(varargin)
   if ~exp_beginfun('symbolic'), return; end
   ...
   <a href="exp_endfun.html" class="code" title="function exp_endfun(varargin)">exp_endfun</a>;


   % define a signal processing function that can only be applied in offline processing
   function signal = set_myoperation(varargin)
   if ~exp_beginfun('offline'), return; end
   ...
   <a href="exp_endfun.html" class="code" title="function exp_endfun(varargin)">exp_endfun</a>;


                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
                                2010-04-14</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="exp_eval.html" class="code" title="function varargout = exp_eval(x,iters)">exp_eval</a>	Evaluate the given expression data structure (or short: expression).</li>
<li><a href="exp_settings.html" class="code" title="function defaults = exp_settings(setting)">exp_settings</a>	Define custom settings (default options) for exp_beginfun.</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="exp_block.html" class="code" title="function res = exp_block(rules, expr, iters)">exp_block</a>	Define a block with dynamically scoped values for symbols used in the contained expression.</li>
<li><a href="exp_cases.html" class="code" title="function matches = exp_cases(exp,match,lev)">exp_cases</a>	Find all occurrences of Match-Expression in In-Expression (at the specified levels).</li>
<li><a href="exp_count.html" class="code" title="function matches = exp_count(exp,match,lev)">exp_count</a>	Count the number of matching subexpressions in some expression (at specified levels).</li>
<li><a href="exp_match.html" class="code" title="function [eq,dict] = exp_match(exp,form,dict)">exp_match</a>	Check whether an expression is matched by a pattern.</li>
<li><a href="exp_not.html" class="code" title="function exp = exp_not(exp)">exp_not</a>	Negate the given expression.</li>
<li><a href="exp_releasehold.html" class="code" title="function exp = exp_releasehold(exp)">exp_releasehold</a>	Peel off a layer of hold expressions from some expression.</li>
<li><a href="exp_replaceall.html" class="code" title="function [exp,changed,rules] = exp_replaceall(exp,rules)">exp_replaceall</a>	Apply substitution rules to some expression.</li>
<li><a href="exp_replacerepeated.html" class="code" title="function [exp,waschanged] = exp_replacerepeated(exp,rules)">exp_replacerepeated</a>	Apply substitution rules to some expression until it no longer changes.</li>
<li><a href="exp_same.html" class="code" title="function res = exp_same(a,b)">exp_same</a>	Check whether two expressions are structurally identical.</li>
<li><a href="exp_set.html" class="code" title="function res = exp_set(lhs,rhs) %#ok<STOUT>">exp_set</a>	An assignment expression; can be used inside exp_block or against the global workspace.</li>
<li><a href="exp_setdelayed.html" class="code" title="function res = exp_setdelayed(lhs,rhs) %#ok<STOUT>">exp_setdelayed</a>	Delayed assignment expression; can be used in exp_block or in the global workspace.</li>
</ul>
<!-- crossreference -->






<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function should_evaluate = exp_beginfun(setting, varargin)</a>
0002 <span class="comment">% Begin the definition of a function with lazy evaluation behavior.</span>
0003 <span class="comment">% Evaluate = exp_beginfun(AttributeSetting, Attributes...)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% General</span>
0006 <span class="comment">% =======</span>
0007 <span class="comment">% If a function uses exp_beginfun/exp_endfun, MATLAB code that uses these functions does not &quot;call&quot;</span>
0008 <span class="comment">% them in an imperative manner, but instead builds symbolic expressions that can be stored,</span>
0009 <span class="comment">% transmitted, or manipulated before/if they are being evaluated. Evaluation is generally done via</span>
0010 <span class="comment">% exp_eval() (or exp_eval_optimized()). Almost all uses of exp_beginfun by functions look like this:</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%   function [res1,res2,...] = my_function(arg1,arg2, ...)</span>
0013 <span class="comment">%   if ~exp_beginfun('somesetting') return; end</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%   ... &lt;actual implementation&gt; ...</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%   exp_endfun;</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% ... where 'somesetting' specifies the behavioral setting for the function. Generally, all</span>
0020 <span class="comment">% functions that operate on data sets and modify the signal content in a way that needs to be</span>
0021 <span class="comment">% replicated online have the setting 'filter', and all functions that have no equivalent during</span>
0022 <span class="comment">% online processing (e.g., marker transcription) have the setting 'editing'. Functions that do</span>
0023 <span class="comment">% processing that cannot be reproduced online have the setting 'offline'. See filters/flt_* and</span>
0024 <span class="comment">% dataset_ops/set_* for some examples. A setting is a shortcut name for an assignment of attributes</span>
0025 <span class="comment">% associated with the function declaration (attributes can also be directly specified to</span>
0026 <span class="comment">% exp_beginfun).</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% Filter and Editing Functions</span>
0030 <span class="comment">% ============================</span>
0031 <span class="comment">% Functions of type 'filter' should be written just like regular EEGLAB signal processing functions</span>
0032 <span class="comment">% (i.e., they receive a data set and some options, and produce a transformed version of the data</span>
0033 <span class="comment">% set), but functions that are supposed to be usable online should be &quot;chunkable&quot;, i.e. they should</span>
0034 <span class="comment">% produce the same sequence of output samples when they are called for consecutive segments (chunks)</span>
0035 <span class="comment">% of the data set. Thus, the function should dump its internal state in an additional output (the</span>
0036 <span class="comment">% 'state' variable) and be able to resume from this state when called on the next chunk. Chunks may</span>
0037 <span class="comment">% well be just a single sample long. During online processing, state will be passed in automatically.</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% In some cases, this strict behavior would be prohibitively inefficient - in this case, the</span>
0040 <span class="comment">% function may refrain to non-adaptive behavior if the chunks are too short. In particular, in</span>
0041 <span class="comment">% BCILAB, it may be assumed that each filter is first called on a complete calibration data set in a</span>
0042 <span class="comment">% single call, and is then either called on a complete test data set in one call (the next 'chunk'),</span>
0043 <span class="comment">% or piecemeal on small blocks of an incoming online stream. ICA, for example, adapts itself only on</span>
0044 <span class="comment">% the calibration data set (i.e. the first chunk) and uses that decomposition for all remaining ones</span>
0045 <span class="comment">% (i.e. during online use).</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% Functions of type 'editing' should be written just like regular EEGLAB data set editing functions</span>
0048 <span class="comment">% (e.g. pop_chanedit), BUT they must not change the data or srate fields.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% Rationale/Background</span>
0051 <span class="comment">% ====================</span>
0052 <span class="comment">% For the purpose of data processing function declarations, the exp_beginfun/exp_endfun contract</span>
0053 <span class="comment">% handles the book-keeping necessary to be able to reproduce the filter (and entire filter chain)</span>
0054 <span class="comment">% 1:1 online, and offers additional functionality, such as transparent caching of results (for later</span>
0055 <span class="comment">% near-instantaneuous retrieval) and the annotation of all data sets with an executable expression</span>
0056 <span class="comment">% which, when invoked, reproduces the data set 1:1, as well as checks to guarantee that no invalid</span>
0057 <span class="comment">% &quot;tampering&quot; is done by the user on data sets (such as running a forward-backward filter in EEGLAB</span>
0058 <span class="comment">% or manually scaling the data).</span>
0059 <span class="comment">%</span>
0060 <span class="comment">% In its general form, the functions exp_beginfun/exp_endfun are part of the machinery that enables</span>
0061 <span class="comment">% symbolic computation in MATLAB (in the style of Mathematica), and the</span>
0062 <span class="comment">% 'filter'/'editing'/'symbolic'/'annotate'/'default' argument is a short-cut which selects default</span>
0063 <span class="comment">% attributes of the function being defined (which can be overridden). Some of these attributes are</span>
0064 <span class="comment">% customizable plugin &quot;slots&quot; (plugins to be applied to each argument or all inputs or all outputs</span>
0065 <span class="comment">% of the function being defined). 'Filter'/'editing' imply such hooks as default attributes, which</span>
0066 <span class="comment">% in turn implement the tamper-proofing checks and some post-processing on the emitted data sets.</span>
0067 <span class="comment">% The post-processing adds fields (subfields of the .tracking field) to the (otherwise arbitrary)</span>
0068 <span class="comment">% data set structs that are produced by the function being defined, most importantly the</span>
0069 <span class="comment">% .tracking.expression, which is an executable (recursive) expression representation which mirrors</span>
0070 <span class="comment">% each data set in symbolic form, and .tracking.online_expression, in the case of filters, which</span>
0071 <span class="comment">% defines the arguments to be used for the respective filter during online processing. These</span>
0072 <span class="comment">% operations are usually completely transparent to the user (and locked away in the .tracking</span>
0073 <span class="comment">% field), and make it exceptionally simple to author components for the toolbox.</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% The symbolic-computation functionality implemented by the expressions/exp_* functions is largely</span>
0076 <span class="comment">% non-overlapping with what the MATLAB Symbolic toolbox offers: the Symbolic toolbox exclusively</span>
0077 <span class="comment">% implements mathematics (e.g. derivatives, integrals, simplifications), while the expression system</span>
0078 <span class="comment">% of BCILAB exclusively implements expression manipulation, such as substitution, pattern matching,</span>
0079 <span class="comment">% hashing, memoization, and reflection. These facilities allow to implement very high-level behavior</span>
0080 <span class="comment">% in functions such as bci_train, such as generic programming (e.g. utl_crossval, utl_searchmodel,</span>
0081 <span class="comment">% utl_gridsearch being non-intrusively adapted to EEG sets, STUDY sets, etc.), optimizations (e.g.</span>
0082 <span class="comment">% in-memory caching and on-disk caching of intermediate results, computational shortcuts, and more</span>
0083 <span class="comment">% in the future), with relatively little coding effort.</span>
0084 <span class="comment">%</span>
0085 <span class="comment">% While, by default, a function is invoked online with the same parameters that were used for</span>
0086 <span class="comment">% offline processing (aside from a 'state' parameter for stateful functions), it is is possible to</span>
0087 <span class="comment">% specify that certain parameters should have different values during online processing. This is</span>
0088 <span class="comment">% enabled by the attribute 'append_online' (list of arguments to be appended in the online case),</span>
0089 <span class="comment">% which can be specified either to exp_beginfun or exp_endfun. Alternatively, the entire expression</span>
0090 <span class="comment">% can be subsituted by setting the 'set_online' attribute (expression to use during online</span>
0091 <span class="comment">% processing).</span>
0092 <span class="comment">%</span>
0093 <span class="comment">% In:</span>
0094 <span class="comment">%  AttributeSetting: baseline attribute assignment for the function; must be specified. Below are</span>
0095 <span class="comment">%                    typical scenarios:</span>
0096 <span class="comment">%                    * defining a function that should not evaluate immediately, but only after</span>
0097 <span class="comment">%                      evaluation by an exp_eval() clause:</span>
0098 <span class="comment">%                      'default' : delayed execution, input fingerprint checks</span>
0099 <span class="comment">%</span>
0100 <span class="comment">%                    * defining a function that processes data sets and should have</span>
0101 <span class="comment">%                      delayed-evaluation semantics:</span>
0102 <span class="comment">%                      'filter'  : functions that do non-trivial processing of data sets, and which</span>
0103 <span class="comment">%                                  should support online replication of some offline processing;</span>
0104 <span class="comment">%                                  attributes: delayed (1), add_impure (1), set_online</span>
0105 <span class="comment">%                                  ('reproduce'), also performs EEGLAB-aware input data set checks &amp;</span>
0106 <span class="comment">%                                  transforms note: when an offline processing is replicated online,</span>
0107 <span class="comment">%                                  the function is called successively on short EEGLAB data sets,</span>
0108 <span class="comment">%                                  with inputs identical to the input parameters as they were</span>
0109 <span class="comment">%                                  snapshot after execution of the function's body (by exp_endfun)</span>
0110 <span class="comment">%                      'editing' : functions that do processing of data sets which has no equivalent</span>
0111 <span class="comment">%                                  in online processing, i.e. which pass the input data through</span>
0112 <span class="comment">%                                  unmodified; attributes: delayed (1), add_impure (1), set_online</span>
0113 <span class="comment">%                                  ('passthrough'), also performs EEGLAB-aware input data set checks</span>
0114 <span class="comment">%                      'offline' : functions that do processing of data sets which cannot be</span>
0115 <span class="comment">%                                  reproduced online; these generate an error, when used within</span>
0116 <span class="comment">%                                  online BCIss; attributes: delayed (1), add_impure (1), set_online</span>
0117 <span class="comment">%                                  ('inapplicable'), also performs EEGLAB-aware input data set</span>
0118 <span class="comment">%                                  checks</span>
0119 <span class="comment">%</span>
0120 <span class="comment">%                    * definining a function that imports or constructs data sets from scratch:</span>
0121 <span class="comment">%                      'import'  : functions that construct a data set from scratch based on</span>
0122 <span class="comment">%                                  arguments that are not data sets</span>
0123 <span class="comment">%</span>
0124 <span class="comment">%                    * defining a function that performs purely symbolic manipulations of</span>
0125 <span class="comment">%                      expressions:</span>
0126 <span class="comment">%                      'symbolic': all inputs are held unevaluated, associated (impure) values are</span>
0127 <span class="comment">%                                  ignored (thus no fingerprinting and no memoization); attributes:</span>
0128 <span class="comment">%                                  delayed (1), hold ('all'), fingerprints unchecked &amp; passed</span>
0129 <span class="comment">%                                  through, memoize (0)</span>
0130 <span class="comment">%                                  note: symbolic functions cannot be used in online code.</span>
0131 <span class="comment">%</span>
0132 <span class="comment">%                    * defining a function that performs immediate (non-lazy) processing of data</span>
0133 <span class="comment">%                      structures, and which shall have their results annotated with an executable</span>
0134 <span class="comment">%                      (repeatable) description of the processing performed:</span>
0135 <span class="comment">%                      'annotate': delayed (0), add_impure (1)</span>
0136 <span class="comment">%</span>
0137 <span class="comment">%</span>
0138 <span class="comment">%   Attributes... : optional name-value pairs to refine attributes of the function being defined:</span>
0139 <span class="comment">%</span>
0140 <span class="comment">%                     'delayed'   : whether the function has delayed-evaluation semantics, i.e. it</span>
0141 <span class="comment">%                                   doesn't evaluate unless passed to exp_eval (default: 1)</span>
0142 <span class="comment">%</span>
0143 <span class="comment">%                     'hold'      : []/'all'/'first'/'rest'; whether to leave all/the first/the</span>
0144 <span class="comment">%                                   remaining arguments or no arguments of the function unevaluated</span>
0145 <span class="comment">%                                   before executing the function body (useful for higher-order</span>
0146 <span class="comment">%                                   functions), (default: [])</span>
0147 <span class="comment">%</span>
0148 <span class="comment">%                     'symbolic'  : whether the function being defined should be evaluated even if it</span>
0149 <span class="comment">%                                   receives unevaluated expressions as arguments (ignoring those</span>
0150 <span class="comment">%                                   arguments that fall under hold) - this is for symbol-manipulating</span>
0151 <span class="comment">%                                   functions that can process unevaluated expressions (0/1, default: 0)</span>
0152 <span class="comment">%</span>
0153 <span class="comment">%                     'add_impure': integrate the original expression into the function value (when</span>
0154 <span class="comment">%                                   evaluated), creating an 'impure expression', 0/1</span>
0155 <span class="comment">%</span>
0156 <span class="comment">%                     'set_online': Relevant only when the settings attribute is 'filter', 'editing'</span>
0157 <span class="comment">%                                   or 'offline', may also be specified in exp_endfun. Introduces an</span>
0158 <span class="comment">%                                   'online expression' into the function value (when evaluated),</span>
0159 <span class="comment">%                                   which is a record of how the resulting data (usually a signal)</span>
0160 <span class="comment">%                                   should be calculated online. Usually, this is identical to how</span>
0161 <span class="comment">%                                   the filter is applied offline.</span>
0162 <span class="comment">%                                   * 'passthrough': the function is skipped in the online</span>
0163 <span class="comment">%                                                    processing</span>
0164 <span class="comment">%                                   * 'reproduce': the function is called online with the same arguments</span>
0165 <span class="comment">%                                                  as in offline processing</span>
0166 <span class="comment">%                                   * 'inapplicable': the function gives an error when used in</span>
0167 <span class="comment">%                                                     online processing</span>
0168 <span class="comment">%                                   * {arg1, arg2, arg3, ...}: the given arguments will be used as</span>
0169 <span class="comment">%                                                              function arguments during online use</span>
0170 <span class="comment">%                                   * expression: the given expression will be used during online</span>
0171 <span class="comment">%                                                 reproduction of the filter</span>
0172 <span class="comment">%</span>
0173 <span class="comment">%                     'append_online' : {arg1, arg2, arg3, ...}: the given arguments will be</span>
0174 <span class="comment">%                                       appended to the function arguments during online use</span>
0175 <span class="comment">%                                       (default: [])</span>
0176 <span class="comment">%</span>
0177 <span class="comment">%                     'argsteps', 'presteps', 'poststeps' : advanced attributes, see also &quot;Advanced</span>
0178 <span class="comment">%                                                           Functionality&quot; section.</span>
0179 <span class="comment">%</span>
0180 <span class="comment">%                     'delayed_online' : whether this function has delayed-evaluation semantics</span>
0181 <span class="comment">%                                        during online processing (default: false)</span>
0182 <span class="comment">%</span>
0183 <span class="comment">% Out:</span>
0184 <span class="comment">%   Evaluate     : whether the body of the function being defined shall be evaluated or skipped</span>
0185 <span class="comment">%</span>
0186 <span class="comment">%</span>
0187 <span class="comment">% Advanced functionality:</span>
0188 <span class="comment">%   The allowed settings are customizable/extensible via the function exp_settings, which maps a</span>
0189 <span class="comment">%   setting string onto a cell array of default attributes (name-value pairs).</span>
0190 <span class="comment">%</span>
0191 <span class="comment">%   During evaluation, each input argument is sent though a customizable sequence of functions,</span>
0192 <span class="comment">%   which can be specified via the 'argsteps' attribute (as a cell array). Further, the attriutes</span>
0193 <span class="comment">%   'presteps' and 'poststeps' are cell arrays of functions that should be invoked before and after</span>
0194 <span class="comment">%   the function body runs, respectively; they operate on a context structure, which is defined</span>
0195 <span class="comment">%   further below. These built-in attributes are the primary mechanism by which custom exp_settings</span>
0196 <span class="comment">%   add functionality to exp_beginfun/exp_endfun (e.g., annotating a dataset with an expression or</span>
0197 <span class="comment">%   checking fingerprints).</span>
0198 <span class="comment">%</span>
0199 <span class="comment">%   The function's behavior can be controlled via dynamically scoped variables, as set by exp_block,</span>
0200 <span class="comment">%   exp_set and exp_setdelayed, or correspondent attributes in exp_beginfun.</span>
0201 <span class="comment">%     These variables can be assigned values, such as 0/1, but may be arbitrary expressions</span>
0202 <span class="comment">%      * fingerprint_check: toggle per-argument fingerprint checking (default: true) - may use</span>
0203 <span class="comment">%        @expression to refer to the argument expression, to implement expression-dependent checking</span>
0204 <span class="comment">%      * fingerprint_create: toggle fingerprint creation (default: true) - may use @expression to</span>
0205 <span class="comment">%        refer to the unevaluated complete expression, to implement expression-dependent checking</span>
0206 <span class="comment">%      * memoize: selectively enable memoization; this is a cell array of the form</span>
0207 <span class="comment">%        {location,expression,location,expression, ...}. location can be either 'disk' or 'memory',</span>
0208 <span class="comment">%        expression should evaluate to true/false, may use @expression to refer to the unevaluated</span>
0209 <span class="comment">%        complete expression, to implement expression-dependent memoization.</span>
0210 <span class="comment">%</span>
0211 <span class="comment">% See also:</span>
0212 <span class="comment">%   exp_endfun, exp_eval, exp_settings</span>
0213 <span class="comment">%</span>
0214 <span class="comment">% Examples:</span>
0215 <span class="comment">%   % a typical function declaration using the expression system</span>
0216 <span class="comment">%   function result = myfunc(myarg,myotherarg,yetanotherarg)</span>
0217 <span class="comment">%   if ~exp_beginfun('somesetting'), return; end</span>
0218 <span class="comment">%   ...</span>
0219 <span class="comment">%   exp_endfun;</span>
0220 <span class="comment">%</span>
0221 <span class="comment">%</span>
0222 <span class="comment">%   % define a filter function using the expression system</span>
0223 <span class="comment">%   % (note that, for filters to work with all BCILAB facilities, the varargin arguments should also</span>
0224 <span class="comment">%   %  be processed via arg_define)</span>
0225 <span class="comment">%   function signal = flt_myfilter(varargin)</span>
0226 <span class="comment">%   if ~exp_beginfun('filter'), return; end</span>
0227 <span class="comment">%   ...</span>
0228 <span class="comment">%   exp_endfun;</span>
0229 <span class="comment">%</span>
0230 <span class="comment">%</span>
0231 <span class="comment">%   % as before, but define that the filter, when applied during online processing, should be passed</span>
0232 <span class="comment">%   % a particular list of additional arguments</span>
0233 <span class="comment">%   function signal = flt_myfilter(varargin)</span>
0234 <span class="comment">%   if ~exp_beginfun('filter'), return; end</span>
0235 <span class="comment">%   ...</span>
0236 <span class="comment">%   exp_endfun('add_online',{'myinternalarg',10, 'my_reserved_argument','test'})</span>
0237 <span class="comment">%</span>
0238 <span class="comment">%</span>
0239 <span class="comment">%   % like before, but this time replace the entire set of arguments; the assumption here is that</span>
0240 <span class="comment">%   % the variable called signal contains the input signal, and that it can be passed to flt_myfilter</span>
0241 <span class="comment">%   % by name</span>
0242 <span class="comment">%   function signal = flt_myfilter(varargin)</span>
0243 <span class="comment">%   if ~exp_beginfun('filter'), return; end</span>
0244 <span class="comment">%   ...</span>
0245 <span class="comment">%   exp_endfun('set_online',{'signal',signal, 'myparam',10,'myotherparam',200})</span>
0246 <span class="comment">%</span>
0247 <span class="comment">%</span>
0248 <span class="comment">%   % like before, but this time define that the filter, when applied online, should go through an</span>
0249 <span class="comment">%   % entirely different function (here assumed to be defined using exp_beginfun itself) with specific</span>
0250 <span class="comment">%   % arguments</span>
0251 <span class="comment">%   function signal = flt_myfilter(varargin)</span>
0252 <span class="comment">%   if ~exp_beginfun('filter'), return; end</span>
0253 <span class="comment">%   ...</span>
0254 <span class="comment">%   exp_endfun('set_online',flt_myfilter_online('signal',signal, 'specialparam1',10))</span>
0255 <span class="comment">%</span>
0256 <span class="comment">%</span>
0257 <span class="comment">%   % define a dataset editing function</span>
0258 <span class="comment">%   function signal = set_myoperation(varargin)</span>
0259 <span class="comment">%   if ~exp_beginfun('editing'), return; end</span>
0260 <span class="comment">%   ...</span>
0261 <span class="comment">%   exp_endfun;</span>
0262 <span class="comment">%</span>
0263 <span class="comment">%</span>
0264 <span class="comment">%   % define a function that operates on expressions symbolically</span>
0265 <span class="comment">%   function result = my_operation(varargin)</span>
0266 <span class="comment">%   if ~exp_beginfun('symbolic'), return; end</span>
0267 <span class="comment">%   ...</span>
0268 <span class="comment">%   exp_endfun;</span>
0269 <span class="comment">%</span>
0270 <span class="comment">%</span>
0271 <span class="comment">%   % define a signal processing function that can only be applied in offline processing</span>
0272 <span class="comment">%   function signal = set_myoperation(varargin)</span>
0273 <span class="comment">%   if ~exp_beginfun('offline'), return; end</span>
0274 <span class="comment">%   ...</span>
0275 <span class="comment">%   exp_endfun;</span>
0276 <span class="comment">%</span>
0277 <span class="comment">%</span>
0278 <span class="comment">%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD</span>
0279 <span class="comment">%                                2010-04-14</span>
0280 dp;
0281 
0282 <span class="comment">% --- obtain &amp; interpret calling context ---</span>
0283 
0284 <span class="comment">% obtain execution context</span>
0285 ctx.stack = dbstack(<span class="string">'-completenames'</span>);
0286 
0287 <span class="comment">% early check of whether the expression system is disabled</span>
0288 <span class="keyword">if</span>  ~strcmp(setting,<span class="string">'symbolic'</span>) &amp;&amp; hlp_resolve(<span class="string">'disable_expressions'</span>,false,ctx) &amp;&amp; ~isequal(varargin,{<span class="string">'delayed_online'</span>,true})
0289     <span class="comment">% and exit exp_beginfun, if so</span>
0290     assignin(<span class="string">'caller'</span>,<span class="string">'exp_internal_context'</span>,struct(<span class="string">'enabled'</span>,0, <span class="string">'exec_ctx'</span>,ctx));
0291     <span class="comment">% the function should evaluate</span>
0292     should_evaluate = 1;
0293     <span class="keyword">return</span>;
0294 <span class="keyword">end</span>
0295 
0296 <span class="comment">% if we're being called by exp_eval, the function should be immediately evaluated - otherwise it may</span>
0297 <span class="comment">% evaluate in a delayed fashion (i.e., only the expression itself is returned)</span>
0298 should_evaluate = any(strncmp(<span class="string">'exp_eval'</span>,{ctx.stack(3:min(4,length(ctx.stack))).name},8));
0299 
0300 <span class="comment">% identify the calling function (i.e., the one using exp_beginfun)</span>
0301 callname = ctx.stack(2).name;
0302 callfile = ctx.stack(2).file;
0303 callfunc = str2func(callname);
0304 [codehash,inargs,outargs] = hlp_fileinfo(callname,callfile);
0305 
0306 
0307 <span class="comment">% --- read the caller's function arguments (and unfold varargin, if any) ---</span>
0308 <span class="keyword">try</span>
0309     parts = {};
0310     <span class="keyword">for</span> i=1:length(inargs)
0311         val = evalin(<span class="string">'caller'</span>,inargs{i});
0312         <span class="keyword">if</span> ~strcmp(inargs{i},<span class="string">'varargin'</span>)
0313             val = {val}; <span class="keyword">end</span>
0314         parts = [parts val]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0315     <span class="keyword">end</span>
0316 <span class="keyword">catch</span>, <span class="keyword">end</span>
0317 
0318 
0319 <span class="comment">% --- parse the attribute settings ---</span>
0320 <span class="keyword">if</span> isempty(varargin) &amp;&amp; strcmp(setting,<span class="string">'symbolic'</span>)
0321     <span class="comment">% fast path: symbolic operations with no settings</span>
0322     <span class="keyword">if</span> ~should_evaluate
0323         <span class="comment">% -&gt; delayed evaluation: compose &amp; return a new expression from transformed</span>
0324         <span class="comment">% arguments</span>
0325         assignin(<span class="string">'caller'</span>,outargs{1},struct(<span class="string">'head'</span>,{callfunc},<span class="string">'parts'</span>,{parts}));
0326         <span class="comment">% also assign [] to all other output arguments</span>
0327         <span class="keyword">for</span> k=2:length(outargs)
0328             assignin(<span class="string">'caller'</span>,outargs{k},[]); <span class="keyword">end</span>
0329     <span class="keyword">else</span>
0330         <span class="comment">% -&gt; immediate evaluation: opt out of exp_endfun() processing (nothing to do for</span>
0331         <span class="comment">% symbolic functions)</span>
0332         assignin(<span class="string">'caller'</span>,<span class="string">'exp_internal_context'</span>,struct(<span class="string">'enabled'</span>,{0}, <span class="string">'exec_ctx'</span>,{ctx}));
0333     <span class="keyword">end</span>
0334     <span class="keyword">return</span>;
0335 <span class="keyword">else</span>
0336     <span class="comment">% regular path: every other case</span>
0337     
0338     <span class="comment">% define general attributes</span>
0339     attribs = {<span class="string">'delayed'</span>,1,<span class="string">'add_impure'</span>,1,<span class="string">'hold'</span>,[],<span class="string">'symbolic'</span>,0,<span class="string">'set_online'</span>,[],<span class="string">'append_online'</span>,[],<span class="string">'delayed_online'</span>,false,<span class="string">'argsteps'</span>,[],<span class="string">'presteps'</span>,[],<span class="string">'poststeps'</span>,[],<span class="string">'fingerprint_check'</span>,[],<span class="string">'fingerprint_create'</span>,[],<span class="string">'memoize'</span>,[]};
0340     
0341     <span class="comment">% set defaults according to the chosen setting</span>
0342     <span class="keyword">switch</span> setting
0343         <span class="keyword">case</span> <span class="string">'symbolic'</span>
0344             defaults = {<span class="string">'add_impure'</span>,0, <span class="string">'symbolic'</span>,1, <span class="string">'hold'</span>,<span class="string">'all'</span>, <span class="string">'fingerprint_check'</span>,0, <span class="string">'fingerprint_create'</span>,<span class="string">'passthrough'</span>, <span class="string">'memoize'</span>,0};
0345         <span class="keyword">case</span> <span class="string">'default'</span>
0346             defaults = {<span class="string">'add_impure'</span>,0, <span class="string">'argsteps'</span>,{@utl_check_fingerprint}};
0347         <span class="keyword">case</span> <span class="string">'annotate'</span>
0348             defaults = {<span class="string">'delayed'</span>,0};
0349         <span class="keyword">otherwise</span>
0350             defaults = <a href="exp_settings.html" class="code" title="function defaults = exp_settings(setting)">exp_settings</a>(setting);
0351     <span class="keyword">end</span>
0352     
0353     <span class="comment">% concatenate general attribs, per-setting defaults and user overrides into one list of</span>
0354     <span class="comment">% name-value pairs (NVPs)</span>
0355     <span class="keyword">if</span> ~iscellstr(varargin(1:2:end))
0356         error(<span class="string">'The given attributes must be name-value pairs.'</span>); <span class="keyword">end</span>
0357     nvps = [attribs defaults varargin];
0358     <span class="comment">% retain only the last assignment for each name</span>
0359     [s,indices] = sort(nvps(1:2:end));
0360     indices(strcmp(s((1:end-1)'),s((2:end)'))) = [];    
0361     <span class="comment">% and turn them into an options struct</span>
0362     opts = cell2struct(nvps(2*indices),nvps(2*indices-1),2);
0363 <span class="keyword">end</span>
0364 
0365 <span class="comment">% if delayed is false, it enforces immediate evaluation</span>
0366 <span class="keyword">if</span> ~opts.delayed
0367     should_evaluate = true; <span class="keyword">end</span>
0368 
0369 
0370 <span class="keyword">if</span> should_evaluate
0371 
0372     <span class="comment">% apply per-argument transformation steps (and pass the full options)</span>
0373     expression = struct(<span class="string">'head'</span>,{callfunc},<span class="string">'parts'</span>,{parts},<span class="string">'codehash'</span>,{codehash});
0374     <span class="keyword">for</span> step = opts.argsteps
0375         <span class="keyword">for</span> p=1:length(parts)
0376             parts{p} = step{1}(parts{p},opts,ctx,expression); <span class="keyword">end</span>
0377     <span class="keyword">end</span>
0378 
0379     <span class="comment">% --- check if the result of evaluating this expression is already in the cache ---</span>
0380       
0381     <span class="comment">% purify the expression</span>
0382     expression = utl_purify_expression(struct(<span class="string">'head'</span>,{callfunc},<span class="string">'parts'</span>,{parts},<span class="string">'codehash'</span>,{codehash}));
0383     
0384     <span class="comment">% quick check if memoization is disabled</span>
0385     <span class="keyword">if</span> ~isequal(opts.memoize,0)
0386         <span class="comment">% do a cache lookup</span>
0387         [action,result] = utl_memoize_lookup(expression,opts.memoize,ctx);
0388         <span class="comment">% act according to outcome</span>
0389         <span class="keyword">if</span> strcmp(action,<span class="string">'return'</span>)
0390             <span class="comment">% assign the retrieved data to the output argument(s)</span>
0391             <span class="keyword">for</span> k=1:length(result)
0392                 assignin(<span class="string">'caller'</span>,outargs{k},result{k}); <span class="keyword">end</span>
0393             <span class="comment">% and make sure that the function does not evaluate further</span>
0394             should_evaluate = 0;
0395             <span class="keyword">return</span>;
0396         <span class="keyword">elseif</span> strcmp(action,<span class="string">'memoize'</span>)
0397             <span class="comment">% remember to memoize the expression later, under the given id(s)</span>
0398             memoize_id = result;
0399         <span class="keyword">else</span>
0400             <span class="comment">% do not memoize the expression</span>
0401             memoize_id = [];
0402         <span class="keyword">end</span>
0403     <span class="keyword">else</span>
0404         memoize_id = [];
0405     <span class="keyword">end</span>
0406     
0407     
0408     <span class="comment">% --- not in cache: evaluate arguments  ---</span>
0409     
0410     <span class="comment">% evaluate the function's arguments (recursively), if they are not held</span>
0411     <span class="keyword">if</span> ~isempty(parts) &amp;&amp; ~any(strcmp(opts.hold,{<span class="string">'all'</span>,<span class="string">'first'</span>}));
0412         parts{1} = <a href="exp_eval.html" class="code" title="function varargout = exp_eval(x,iters)">exp_eval</a>(parts{1},inf);
0413         <span class="keyword">if</span> ~opts.symbolic &amp;&amp; ~is_evaluated(parts{1})
0414             <span class="comment">% one of the inputs could not be evaluated (e.g. using an undefined symbol): return the</span>
0415             <span class="comment">% expression</span>
0416             assignin(<span class="string">'caller'</span>,outargs{1},expression);
0417             <span class="comment">% also assign [] to all other output arguments</span>
0418             <span class="keyword">for</span> k=2:length(outargs)
0419                 assignin(<span class="string">'caller'</span>,outargs{k},[]); <span class="keyword">end</span>
0420             should_evaluate = false;
0421             <span class="keyword">return</span>;
0422         <span class="keyword">end</span>
0423     <span class="keyword">end</span>    
0424     <span class="keyword">if</span> ~any(strcmp(opts.hold,{<span class="string">'all'</span>,<span class="string">'rest'</span>}))
0425         <span class="keyword">for</span> i=2:length(parts)
0426             parts{i} = <a href="exp_eval.html" class="code" title="function varargout = exp_eval(x,iters)">exp_eval</a>(parts{i},inf); <span class="comment">%#ok&lt;AGROW&gt;</span>
0427             <span class="keyword">if</span> ~opts.symbolic &amp;&amp; ~is_evaluated(parts{i})
0428                 <span class="comment">% one of the inputs could not be evaluated (e.g. using an undefined symbol): return</span>
0429                 <span class="comment">% the expression</span>
0430                 assignin(<span class="string">'caller'</span>,outargs{1},expression);
0431                 <span class="comment">% also assign [] to all other output arguments</span>
0432                 <span class="keyword">for</span> k=2:length(outargs)
0433                     assignin(<span class="string">'caller'</span>,outargs{k},[]); <span class="keyword">end</span>
0434                 should_evaluate = false;
0435                 <span class="keyword">return</span>;
0436             <span class="keyword">end</span>
0437         <span class="keyword">end</span>
0438     <span class="keyword">end</span>
0439     
0440     <span class="comment">% --- prepare function execution ---</span>
0441     
0442     <span class="comment">% begin measuring the evaluation time of the expression ...</span>
0443     eval_time = tic;
0444     <span class="comment">% ... and measure the size of the inputs (both used to determine the best cache location)</span>
0445     stats = whos(<span class="string">'parts'</span>);
0446     input_size = stats.bytes;
0447     
0448     <span class="comment">% create a context struct to keep track of the inputs, outputs, and attributes of the function</span>
0449     <span class="comment">% throughout its evaluation</span>
0450     context = struct( <span class="keyword">...</span>
0451         <span class="string">'inargs'</span>,{inargs}, <span class="string">'outargs'</span>,{outargs}, <span class="keyword">...</span><span class="comment">                     % input/output argument names</span>
0452         <span class="string">'ws_input_pre'</span>,{struct()}, <span class="string">'ws_output_post'</span>,{struct()}, <span class="keyword">...</span><span class="comment">     % input/output function workspace before/after evaluation of the function's body</span>
0453         <span class="string">'expression_preeval'</span>,{expression}, <span class="string">'expression_posteval'</span>, struct(<span class="string">'head'</span>,{callfunc},<span class="string">'parts'</span>,{parts}), <span class="keyword">...</span><span class="comment"> % expression arguments (original and evaluated)</span>
0454         <span class="string">'opts'</span>,{opts}, <span class="string">'eval_time'</span>,{eval_time}, <span class="string">'input_size'</span>,{input_size}, <span class="string">'memoize_id'</span>,{memoize_id}, <span class="string">'exec_ctx'</span>,{ctx}, <span class="string">'enabled'</span>,{1});    <span class="comment">% misc fields</span>
0455     
0456     <span class="comment">% re-derive the function's input &amp; output workspace from the now evaluated parts (folding</span>
0457     <span class="comment">% varargs again)</span>
0458     <span class="keyword">for</span> i=1:length(parts)
0459         <span class="keyword">if</span> strcmp(inargs{i},<span class="string">'varargin'</span>)
0460             context.ws_input_pre.(inargs{i}) = parts(i:end);
0461             <span class="keyword">break</span>;
0462         <span class="keyword">else</span>
0463             context.ws_input_pre.(inargs{i}) = parts{i};
0464         <span class="keyword">end</span>
0465     <span class="keyword">end</span>
0466     
0467     <span class="comment">% execute the prestep(s) on the function workspace</span>
0468     <span class="keyword">for</span> step = opts.presteps'
0469         context = step{1}(context); <span class="keyword">end</span>
0470     
0471     <span class="comment">% store the context object...</span>
0472     assignin(<span class="string">'caller'</span>,<span class="string">'exp_internal_context'</span>,context);
0473 
0474     <span class="comment">% assign all input for the function body's execution</span>
0475     <span class="keyword">for</span> fn=fieldnames(context.ws_input_pre)'
0476         assignin(<span class="string">'caller'</span>,fn{1},context.ws_input_pre.(fn{1})); <span class="keyword">end</span>
0477     
0478     <span class="comment">% (from here on, the function body will execute)</span>
0479 <span class="keyword">else</span>
0480     
0481     <span class="comment">% --- delayed evaluation: return the expression ---</span>
0482 
0483     expression = struct(<span class="string">'head'</span>,{callfunc},<span class="string">'parts'</span>,{parts},<span class="string">'codehash'</span>,{codehash});
0484     assignin(<span class="string">'caller'</span>,outargs{1},expression);
0485     <span class="comment">% also assign [] to all other output arguments</span>
0486     <span class="keyword">for</span> k=2:length(outargs)
0487         assignin(<span class="string">'caller'</span>,outargs{k},[]); <span class="keyword">end</span>
0488     
0489     <span class="comment">% (the function body will return immediately, as the should_evaluate output is false)</span>
0490 <span class="keyword">end</span></pre></div>

<hr><address>Generated on Wed 19-Aug-2015 18:06:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>